

# æ•°ç»„

### 1.å­æ•°ç»„èŒƒå›´å’Œ(ä¸­ç­‰)



è¾“å…¥ï¼šnums = [1,2,3]
è¾“å‡ºï¼š4
è§£é‡Šï¼šnums çš„ 6 ä¸ªå­æ•°ç»„å¦‚ä¸‹æ‰€ç¤ºï¼š
[1]ï¼ŒèŒƒå›´ = æœ€å¤§ - æœ€å° = 1 - 1 = 0 
[2]ï¼ŒèŒƒå›´ = 2 - 2 = 0
[3]ï¼ŒèŒƒå›´ = 3 - 3 = 0
[1,2]ï¼ŒèŒƒå›´ = 2 - 1 = 1
[2,3]ï¼ŒèŒƒå›´ = 3 - 2 = 1
[1,2,3]ï¼ŒèŒƒå›´ = 3 - 1 = 2
æ‰€æœ‰èŒƒå›´çš„å’Œæ˜¯ 0 + 0 + 0 + 1 + 1 + 2 = 4



**æ€è·¯ï¼šè¿­ä»£çš„è®¡ç®—å‡ºæ¯æ¬¡å­åºåˆ—çš„æœ€å¤§å€¼å’Œæœ€å°å€¼å¹¶ä¿å­˜**

```
long long subArrayRanges(int* nums, int numsSize){
    double sum=0;
    
    for(int i=0;i<numsSize;++i){
        int max=nums[i],min=nums[i];
        for(int j=i+1;j<numsSize;++j){
            max=max>nums[j]?max:nums[j];
            min=min<nums[j]?min:nums[j];
            sum+=max-min;
        }
    }
    return sum;
}
```



### 2.æ¨è¾‰ä¸‰è§’å½¢(ç®€å•)

```
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** generate(int numRows, int* returnSize, int** returnColumnSizes){
    *returnSize=numRows;
    *returnColumnSizes=malloc(sizeof(int)*numRows);
    
    int **a=malloc(sizeof(int*)*numRows);//è¿”å›çš„æ•°ç»„æŒ‡é’ˆ

    for(int i=0;i<numRows;++i){
        a[i]=malloc(sizeof(int)*(i+1));
        (*returnColumnSizes)[i]=i+1;
        a[i][0]=a[i][i]=1;

        for(int j=1;j<i;++j){
            a[i][j]=a[i-1][j-1]+a[i-1][j];
        }

    }
    return a;
}
```



### 3.åŠ ä¸€(ç®€å•)



```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 /*
    åˆ†æƒ…å†µè¿›è¡Œè®¨è®º
    1.ä¸ç”¨è¿›ä½
    2.è¿›ä½
    3.è¿›ä½ä¸”éœ€è¦å¼€è¾Ÿæ–°ç©ºé—´
 */
int* plusOne(int* digits, int digitsSize, int* returnSize){
    if(digits[digitsSize-1]!=9){//ç¬¬ä¸€ç§æƒ…å†µ
        digits[digitsSize-1]++;
        *returnSize=digitsSize;
        return digits;
    }
    else{
        for(int i=digitsSize-1;i>=0;--i){//ä»åå¾€å‰æŸ¥ç…§
            if(digits[i]!=9){
                digits[i]++;
                *returnSize=digitsSize;
                return digits;//å¦‚æœå‘ç°ä¸æ˜¯å…¨éƒ¨ä¸º9å°±è¿›ä¸€ä½ç„¶åè¿”å›åŸæ•°ç»„
            }
            else digits[i]=0;
        }
        //ç¬¬ä¸‰ç§ï¼šå¼€è¾Ÿæ–°ç©ºé—´ï¼Œå°†ç¬¬ä¸€ä¸ªä¸º1ï¼Œåé¢å…¨éƒ¨ä¸º0
        int *result=(int*)malloc(sizeof(int)*(digitsSize+1));
        result[0]=1;
        int cnt=0;
        *returnSize=digitsSize+1;
        for(int i=1;i<=digitsSize;++i)result[i]=0;
        return result;
    }
    
}
```





### 3.ç®€æ˜“é“¶è¡Œç³»ç»Ÿ(ç®—ç®€å•å§)





```
/*
    é“¶è¡Œç³»ç»Ÿ   æ•°ç»„ é¡ºåºè¡¨
*/
typedef struct  bank{
    long long  * accoun;
    int max;
} Bank;


Bank* bankCreate(long long* balance, int balanceSize) {
    Bank *bal=(Bank*)malloc(sizeof(struct bank));
    bal->accoun=(long long*)malloc(sizeof(long long)*balanceSize);
    bal->max=balanceSize;
    for(int i=0;i<balanceSize;++i)bal->accoun[i]=balance[i];
    return bal;
}
//è½¬è´¦
bool bankTransfer(Bank* obj, int account1, int account2, long long money) {
    if(account1>obj->max||account2>obj->max||obj->accoun[account1-1]<money)return false;
    obj->accoun[account1-1]-=money;
    obj->accoun[account2-1]+=money;
    return true;
}
//å­˜é’±  
bool bankDeposit(Bank* obj, int account, long long money) {
    if(account>obj->max||account<0)return false;
    obj->accoun[account-1]+=money;
    return true;
}
//å–é’±
bool bankWithdraw(Bank* obj, int account, long long money) {
    if(account>obj->max||obj->accoun[account-1]<money)return false;
    obj->accoun[account-1]-=money;
    return true;
}

void bankFree(Bank* obj) {
    free(obj->accoun);
}

/**
 * Your Bank struct will be instantiated and called as such:
 * Bank* obj = bankCreate(balance, balanceSize);
 * bool param_1 = bankTransfer(obj, account1, account2, money);
 
 * bool param_2 = bankDeposit(obj, account, money);
 
 * bool param_3 = bankWithdraw(obj, account, money);
 
 * bankFree(obj);
*/
```



### 4.æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ(medium)



ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•´æ•°æ•°ç»„ nums å’Œ ä¸€ä¸ªç›®æ ‡å€¼ targetã€‚è¯·ä½ ä» nums ä¸­é€‰å‡ºä¸‰ä¸ªæ•´æ•°ï¼Œä½¿å®ƒä»¬çš„å’Œä¸ target æœ€æ¥è¿‘ã€‚

è¿”å›è¿™ä¸‰ä¸ªæ•°çš„å’Œã€‚

å‡å®šæ¯ç»„è¾“å…¥åªå­˜åœ¨æ°å¥½ä¸€ä¸ªè§£ã€‚

 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šnums = [-1,2,1,-4], target = 1
è¾“å‡ºï¼š2
è§£é‡Šï¼šä¸ target æœ€æ¥è¿‘çš„å’Œæ˜¯ 2 (-1 + 2 + 1 = 2) ã€‚
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šnums = [0,0,0], target = 1
è¾“å‡ºï¼š0

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/3sum-closest





```
int comp(const void*a,const void *b){
    return *(int*)a-*(int*)b;
}
int threeSumClosest(int* nums, int numsSize, int target){
    //æ’åº åŒæŒ‡é’ˆ
    
    qsort(nums,numsSize,sizeof(int),comp);
    int ans=nums[0]+nums[1]+nums[2];
    for(int i=0;i<numsSize-2;++i){
        int left=i+1,right=numsSize-1;
        while(left<right){
            int sum=nums[i]+nums[left]+nums[right];
            if(abs(sum-target)<abs(ans-target)){
                ans=sum;
                //printf("%d %d %d   ",nums[i],nums[left],nums[right]);
            }
            else if(sum>target)right--;
            else if(sum<target)left++;
            else return target;
        }
    }
    return ans;
}
```







### 5.èºæ—‹çŸ©é˜µ(medium)



```
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes){
    int idex=1;
    int left=0;
    int right=n-1;
    int up=0;
    int down=n-1;
    *returnColumnSizes=(int*)malloc(sizeof(int)*n);
    *returnSize=n;
    int **ans=(int**)malloc(sizeof(int*)*n);
    for(int i=0;i<n;++i){
        ans[i]=(int*)malloc(sizeof(int)*n);
        (*returnColumnSizes)[i]=n;
    }
    while(up<=down&&left<=right){
        for(int i=left;i<=right;++i)ans[up][i]=idex++;//ğŸ‘†
        up++;
        for(int i=up;i<=down;++i)ans[i][right]=idex++;//ğŸ‘‰
        right--;
        for(int i=right;i>=left&&up<=down;--i)ans[down][i]=idex++;//ğŸ‘ˆ
        down--;
        for(int i=down;i>=up&&left<=right;--i)ans[i][left]=idex++;//ğŸ‘‡
        left++;
    }
    return ans;
}
```



### 6.å‰Kä¸ªé«˜é¢‘å…ƒç´ (medium)



ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ è¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ k é«˜çš„å…ƒç´ ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚

 

ç¤ºä¾‹ 1:

è¾“å…¥: nums = [1,1,1,2,2,3], k = 2
è¾“å‡º: [1,2]
ç¤ºä¾‹ 2:

è¾“å…¥: nums = [1], k = 1
è¾“å‡º: [1]

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/top-k-frequent-elements





```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 /*
    å¿«é€Ÿæ’åº
    å°†æ•°ç»„åŠæ¬¡æ•°æ”¾å…¥ç»“æ„ä½“ï¼Œå¯¹ç»“æ„ä½“è¿›è¡Œæ’åºã€‚è¿”å›å‰kä¸ª
 */
 
 //å»ºç«‹ç»“æ„ä½“
 struct time{
     int val;
     int cnt;
 };
 //æ•°ç»„æ’åº
 int comp(const void*a,const void*b){
     return *(int*)a-*(int*)b;
 }
 //ç»“æ„ä½“æ’åº
 int compstruct(const void *a,const void*b){
     return (*(struct time*)b).cnt-(*(struct time*)a).cnt;
 }
int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){
    //å¯¹æ•°ç»„è¿›è¡Œæ’åº
    qsort(nums,numsSize,sizeof(int),comp);
    //ç»“æ„ä½“æ•°ç»„
    struct time a[numsSize];
    int j=0;
    a[0].val=nums[0];
    a[0].cnt=1;
    //å°†æ•°ç»„æ”¾å…¥ç»“æ„ä½“
    for(int i=1;i<numsSize;++i){
        if(nums[i]==a[j].val){
            a[j].cnt++;
        }
        else{
            j++;
            a[j].val=nums[i];
            a[j].cnt=1;
        }
    }
    //å¯¹ç»“æ„ä½“è¿›è¡Œæ’åº
    qsort(a,j+1,sizeof(struct time),compstruct);
    //æ„é€ è¿”å›æ•°ç»„
    int *result=(int*)malloc(sizeof(int)*k);
    for(int i=0;i<k;++i){
        result[i]=a[i].val;
    }
    *returnSize=k;
    return result;
}
```



### 7.æ±‚ä¸‰è§’å½¢çš„æœ€å¤§å‘¨é•¿(ç®€å•)



ç»™å®šç”±ä¸€äº›æ­£æ•°ï¼ˆä»£è¡¨é•¿åº¦ï¼‰ç»„æˆçš„æ•°ç»„ `nums` ï¼Œè¿”å› *ç”±å…¶ä¸­ä¸‰ä¸ªé•¿åº¦ç»„æˆçš„ã€**é¢ç§¯ä¸ä¸ºé›¶**çš„ä¸‰è§’å½¢çš„æœ€å¤§å‘¨é•¿* ã€‚å¦‚æœä¸èƒ½å½¢æˆä»»ä½•é¢ç§¯ä¸ä¸ºé›¶çš„ä¸‰è§’å½¢ï¼Œè¿”å› `0`ã€‚



```
/*
    æ’åº
    æŸ¥ç…§ï¼Œçœ‹æ˜¯å¦ç¬¦åˆ
*/
int comp(const void*a,const void*b){
    return *(int*)b-*(int*)a;
}
int largestPerimeter(int* nums, int numsSize){
    qsort(nums,numsSize,sizeof(int),comp);
    for(int i=2;i<numsSize;++i){
        if(nums[i-2]<nums[i-1]+nums[i])return nums[i]+nums[i-1]+nums[i-2];
    }
    return 0;
}
```



### 8.æ‰¾åˆ°æœ€è¿‘çš„æœ‰ç›¸åŒ X æˆ– Y åæ ‡çš„ç‚¹(ç®€å•)

ç»™ä½ ä¸¤ä¸ªæ•´æ•° x å’Œ y ï¼Œè¡¨ç¤ºä½ åœ¨ä¸€ä¸ªç¬›å¡å°”åæ ‡ç³»ä¸‹çš„ (x, y) å¤„ã€‚åŒæ—¶ï¼Œåœ¨åŒä¸€ä¸ªåæ ‡ç³»ä¸‹ç»™ä½ ä¸€ä¸ªæ•°ç»„ points ï¼Œå…¶ä¸­ points[i] = [ai, bi] è¡¨ç¤ºåœ¨ (ai, bi) å¤„æœ‰ä¸€ä¸ªç‚¹ã€‚å½“ä¸€ä¸ªç‚¹ä¸ä½ æ‰€åœ¨çš„ä½ç½®æœ‰ç›¸åŒçš„ x åæ ‡æˆ–è€…ç›¸åŒçš„ y åæ ‡æ—¶ï¼Œæˆ‘ä»¬ç§°è¿™ä¸ªç‚¹æ˜¯ æœ‰æ•ˆçš„ ã€‚

è¯·è¿”å›è·ç¦»ä½ å½“å‰ä½ç½® æ›¼å“ˆé¡¿è·ç¦» æœ€è¿‘çš„ æœ‰æ•ˆ ç‚¹çš„ä¸‹æ ‡ï¼ˆä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰ã€‚å¦‚æœæœ‰å¤šä¸ªæœ€è¿‘çš„æœ‰æ•ˆç‚¹ï¼Œè¯·è¿”å›ä¸‹æ ‡ æœ€å° çš„ä¸€ä¸ªã€‚å¦‚æœæ²¡æœ‰æœ‰æ•ˆç‚¹ï¼Œè¯·è¿”å› -1 ã€‚

ä¸¤ä¸ªç‚¹ (x1, y1) å’Œ (x2, y2) ä¹‹é—´çš„ æ›¼å“ˆé¡¿è·ç¦» ä¸º abs(x1 - x2) + abs(y1 - y2) ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate





æ¯æ¬¡è®¡ç®—å‡ºè·ç¦»æ¥ï¼Œå¦‚æœæ›´å°å°±æ›´æ–°ç­”æ¡ˆ



```
int nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){
    int a=INT_MAX;
    int ans=-1;
    for(int i=0;i<pointsSize;++i){
        if(x==points[i][0]||y==points[i][1]){
            int sum=abs(x-points[i][0])+abs(y-points[i][1]);
            if(sum<a){
                a=sum;
                ans=i;
            }
        }
    }
    return ans;
}
```



### 9.å›¾ç‰‡å¹³æ»‘å™¨(ç®€å•)



å›¾åƒå¹³æ»‘å™¨ æ˜¯å¤§å°ä¸º 3 x 3 çš„è¿‡æ»¤å™¨ï¼Œç”¨äºå¯¹å›¾åƒçš„æ¯ä¸ªå•å…ƒæ ¼å¹³æ»‘å¤„ç†ï¼Œå¹³æ»‘å¤„ç†åå•å…ƒæ ¼çš„å€¼ä¸ºè¯¥å•å…ƒæ ¼çš„å¹³å‡ç°åº¦ã€‚

æ¯ä¸ªå•å…ƒæ ¼çš„  å¹³å‡ç°åº¦ å®šä¹‰ä¸ºï¼šè¯¥å•å…ƒæ ¼è‡ªèº«åŠå…¶å‘¨å›´çš„ 8 ä¸ªå•å…ƒæ ¼çš„å¹³å‡å€¼ï¼Œç»“æœéœ€å‘ä¸‹å–æ•´ã€‚ï¼ˆå³ï¼Œéœ€è¦è®¡ç®—è“è‰²å¹³æ»‘å™¨ä¸­ 9 ä¸ªå•å…ƒæ ¼çš„å¹³å‡å€¼ï¼‰ã€‚

å¦‚æœä¸€ä¸ªå•å…ƒæ ¼å‘¨å›´å­˜åœ¨å•å…ƒæ ¼ç¼ºå¤±çš„æƒ…å†µï¼Œåˆ™è®¡ç®—å¹³å‡ç°åº¦æ—¶ä¸è€ƒè™‘ç¼ºå¤±çš„å•å…ƒæ ¼ï¼ˆå³ï¼Œéœ€è¦è®¡ç®—çº¢è‰²å¹³æ»‘å™¨ä¸­ 4 ä¸ªå•å…ƒæ ¼çš„å¹³å‡å€¼ï¼‰ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/image-smoother



```
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
/*
    æš´åŠ›æœç´¢
 */
 int get(int**img,int row,int col,int maxCol,int maxRow){
     int sum=0;
     int count=0;
     for(int i=row-1;i<=row+1;++i){
         if(i<0||i>=maxRow)continue;
         for(int j=col-1;j<=col+1;++j){
             if(j<0||j>=maxCol)continue;
                 sum+=img[i][j];
                 count++;
         }
     }
     return sum/count;
 }
int** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes){
    int maxRow=imgSize;
    int maxCol=imgColSize[0];
    *returnSize=maxRow;
    //è¿”å›çš„æŒ‡é’ˆ
    *returnColumnSizes=(int*)malloc(sizeof(int)*maxRow);
    //è¿”å›æ•°ç»„
    int **result=(int**)malloc(sizeof(int*)*maxRow);
    //çˆ†æœ
    int sum=0;
    for(int i=0;i<maxRow;++i){
        //åˆ†é…ç©ºé—´
        (*returnColumnSizes)[i]=maxCol;
        result[i]=(int*)malloc(sizeof(int)*maxCol);
        for(int j=0;j<maxCol;++j){
            result[i][j]=get(img,i,j,maxCol,maxRow);
        }
    }
    return result;
}
```



### 10.ç¼€ç‚¹æˆçº¿(ç®€å•)



```
/*
    çœ‹æ–œç‡ï¼Œé˜²æ­¢åˆ†æ¯å‡ºç°é›¶ï¼Œç”¨ä¹˜æ³•
*/
bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize){
    int x1=coordinates[1][0]-coordinates[0][0],y1=coordinates[1][1]-coordinates[0][1];
    for(int i=2;i<coordinatesSize;++i){
        int x2=coordinates[i][0]-coordinates[i-1][0],y2=coordinates[i][1]-coordinates[i-1][1];
        if(x1*y2!=x2*y1)return false;
    }
    return true;
}
```



### 11.é‡å¡‘çŸ©é˜µ(ç®€å•)



åœ¨ MATLAB ä¸­ï¼Œæœ‰ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„å‡½æ•° reshape ï¼Œå®ƒå¯ä»¥å°†ä¸€ä¸ª m x n çŸ©é˜µé‡å¡‘ä¸ºå¦ä¸€ä¸ªå¤§å°ä¸åŒï¼ˆr x cï¼‰çš„æ–°çŸ©é˜µï¼Œä½†ä¿ç•™å…¶åŸå§‹æ•°æ®ã€‚

ç»™ä½ ä¸€ä¸ªç”±äºŒç»´æ•°ç»„ mat è¡¨ç¤ºçš„ m x n çŸ©é˜µï¼Œä»¥åŠä¸¤ä¸ªæ­£æ•´æ•° r å’Œ c ï¼Œåˆ†åˆ«è¡¨ç¤ºæƒ³è¦çš„é‡æ„çš„çŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°ã€‚

é‡æ„åçš„çŸ©é˜µéœ€è¦å°†åŸå§‹çŸ©é˜µçš„æ‰€æœ‰å…ƒç´ ä»¥ç›¸åŒçš„ è¡Œéå†é¡ºåº å¡«å……ã€‚

å¦‚æœå…·æœ‰ç»™å®šå‚æ•°çš„ reshape æ“ä½œæ˜¯å¯è¡Œä¸”åˆç†çš„ï¼Œåˆ™è¾“å‡ºæ–°çš„é‡å¡‘çŸ©é˜µï¼›å¦åˆ™ï¼Œè¾“å‡ºåŸå§‹çŸ©é˜µã€‚

 

ç¤ºä¾‹ 1ï¼š


è¾“å…¥ï¼šmat = [[1,2],[3,4]], r = 1, c = 4
è¾“å‡ºï¼š[[1,2,3,4]]
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šmat = [[1,2],[3,4]], r = 2, c = 4
è¾“å‡ºï¼š[[1,2],[3,4]]

```
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){
    int m=matSize;//è¡Œæ•°
    int n=matColSize[0];//è¯¥æ•°ç»„ç”¨æ¥æ ‡è®°æ¯ä¸€è¡Œçš„åˆ—æ•°

    if(r*c!=matSize*(*matColSize)){
        *returnSize=matSize;
        *returnColumnSizes=matColSize;
        return mat;
    }//å¦‚æœä¸å¯¹ç›´æ¥è¿”å›åŸæ•°ç»„

    *returnSize=r;
    *returnColumnSizes=(int*)malloc(sizeof(int)*r);
    
    int **ans=(int*)malloc(sizeof(int*)*r);//å¼€è¾ŸæŒ‡é’ˆæ•°ç»„ï¼ŒæŒ‡å‘rè¡Œï¼Œè¿˜æ²¡æœ‰å»ç¡®å®šå¤§å°
    for(int i=0;i<r;i++){
        (*returnColumnSizes)[i]=c;//è¯¥æ•°ç»„ç”¨æ¥æ ‡è®°æ¯ä¸€è¡Œçš„åˆ—æ•°ï¼Œæ–°æ•°ç»„çš„åˆ—æ•°ä¸ºc
        ans[i]=(int*)malloc(sizeof(int)*c);//æ¯ä¸€è¡ŒæŒ‡é’ˆæŒ‡å‘æ•°ç»„ç©ºé—´å¤§å°
    }
    
    for (int i = 0; i < r*c; i++) {
        ans[i / c][i % c] = mat[i / n][i % n];
    }

    return ans;
}
```









# å­—ç¬¦ä¸²









### 1.ä¸¤ä¸ªåˆ—è¡¨çš„æœ€å°ç´¢å¼•æ€»å’Œ

599

```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 /*
    æš´åŠ›å¾ªç¯
    æœ€å°ç´¢å¼•å’Œ
 */
char ** findRestaurant(char ** list1, int list1Size, char ** list2, int list2Size, int* returnSize){
    char ** result=(char*)malloc(sizeof(char*)*list1Size);
    *returnSize=0;
    int min=INT_MAX;
    int i=0,j=0;
    for( i=0;i<list1Size;++i){
        for( j=0;j<list2Size;++j){
            if(strcmp(list1[i],list2[j])==0){
                if(i+j<min){//è®°å½•å’Œæ›´æ–°æœ€å°ç´¢å¼•å’Œ
                    *returnSize=0;
                    min=i+j;
                    result[(*returnSize)++]=list1[i];

                }
                else if(i+j==min){
                    result[(*returnSize)++]=list1[i];
                }
            }
        }
    }
    return result;
}
```





### 2.é¢ å€’å­—ç¬¦ä¸²ä¸­çš„å•è¯(medium)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œé¢ å€’å­—ç¬¦ä¸²ä¸­ å•è¯ çš„é¡ºåºã€‚

å•è¯ æ˜¯ç”±éç©ºæ ¼å­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ã€‚s ä¸­ä½¿ç”¨è‡³å°‘ä¸€ä¸ªç©ºæ ¼å°†å­—ç¬¦ä¸²ä¸­çš„ å•è¯ åˆ†éš”å¼€ã€‚

è¿”å› å•è¯ é¡ºåºé¢ å€’ä¸” å•è¯ ä¹‹é—´ç”¨å•ä¸ªç©ºæ ¼è¿æ¥çš„ç»“æœå­—ç¬¦ä¸²ã€‚

æ³¨æ„ï¼šè¾“å…¥å­—ç¬¦ä¸² sä¸­å¯èƒ½ä¼šå­˜åœ¨å‰å¯¼ç©ºæ ¼ã€å°¾éšç©ºæ ¼æˆ–è€…å•è¯é—´çš„å¤šä¸ªç©ºæ ¼ã€‚è¿”å›çš„ç»“æœå­—ç¬¦ä¸²ä¸­ï¼Œå•è¯é—´åº”å½“ä»…ç”¨å•ä¸ªç©ºæ ¼åˆ†éš”ï¼Œä¸”ä¸åŒ…å«ä»»ä½•é¢å¤–çš„ç©ºæ ¼ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/reverse-words-in-a-string





```
/*
    åˆ†ä¸‰æ­¥
    1ã€å»æ‰å¼€å¤´ç»“å°¾çš„ç©ºæ ¼
        å¿«æ…¢æŒ‡é’ˆ
            è®©å¿«æŒ‡é’ˆèµ°åˆ°ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹
        ç»“å°¾ç©ºæ ¼
            çœ‹ç»“å°¾fastä¸ºä»€ä¹ˆ
                ä¸€ï¼šç»“å°¾ç©ºæ ¼ï¼šè®©æ…¢æŒ‡é’ˆåŠ ä¸€ç»“å°¾
                äºŒï¼šç»“å°¾æ˜¯å­—ç¬¦ï¼šå°†å¿«æŒ‡é’ˆæœ€åä¸€ä¸ªåŠ å…¥åå†ç»“å°¾
    2.å»æ‰ä¸­é—´çš„ç©ºæ ¼
        å¦‚æœfastå’Œfast+1ä¸ºç©ºæ ¼å°±fast++
    3.è¿›è¡Œå•è¯çš„åè½¬-å…¨éƒ¨åè½¬+é€ä¸ªåè½¬


*/
//åè½¬å‡½æ•°
void reverse(char *s,int left,int right){
    while(left<right){
        char t=s[left];
        s[left++]=s[right];
        s[right--]=t;
    }
    return s;
}
char * reverseWords(char * s){
    int len=strlen(s);

    //å»é™¤å¼€å¤´ç©ºæ ¼
    int low=0,fast=0;
    while(s[fast]==' ')fast++;

    //å»é™¤å•è¯ä¸­é—´çš„ç©ºæ ¼
    while(fast<(len-1)){
        if(s[fast]==' '&&s[fast+1]==' ')fast++;
        else s[low++]=s[fast++];
    }

    //ç»“å°¾çš„ç©ºæ ¼,æœ€åä¼šç•™å‡ºä¸€ä¸ªä½ç½®
    if(s[fast]==' '){
        s[low]='\0';
    }
    else{
        s[low++]=s[fast];
        s[low]='\0';
    }
    //è¿›è¡Œå­—ç¬¦ä¸²åè½¬
    reverse(s,0,low-1);
    
    //å•è¯åè½¬
    for(int i=0;i<low;++i){
        int j=i;
        while(j<low&&s[j]!=' ')j++;
        reverse(s,i,j-1);
        i=j++;
    }
    return s;
}
```





### 3.å­—ç¬¦ä¸²çš„æœ€çŸ­è·ç¦»



```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* shortestToChar(char * s, char c, int* returnSize){
    int len=strlen(s);
    *returnSize=len;
    int *result=(int*)malloc(sizeof(int)*len);
    int idex=-2*len;
    for(int i=0;i<len;++i){
        if(s[i]==c)idex=i;
        result[i]=i-idex;
    }
    idex=2*len;
    for(int i=len-1;i>=0;--i){
        if(s[i]==c)idex=i;
        result[i]=fmin(result[i],idex-i);
    }
    return result;
}
```



### 4.æœ€é•¿ç‰¹æ®Šå­åºåˆ—

ç»™å®šå­—ç¬¦ä¸²åˆ—è¡¨ strs ï¼Œè¿”å›å…¶ä¸­ æœ€é•¿çš„ç‰¹æ®Šåºåˆ— ã€‚å¦‚æœæœ€é•¿ç‰¹æ®Šåºåˆ—ä¸å­˜åœ¨ï¼Œè¿”å› -1 ã€‚

ç‰¹æ®Šåºåˆ— å®šä¹‰å¦‚ä¸‹ï¼šè¯¥åºåˆ—ä¸ºæŸå­—ç¬¦ä¸² ç‹¬æœ‰çš„å­åºåˆ—ï¼ˆå³ä¸èƒ½æ˜¯å…¶ä»–å­—ç¬¦ä¸²çš„å­åºåˆ—ï¼‰ã€‚

 s çš„ å­åºåˆ—å¯ä»¥é€šè¿‡åˆ å»å­—ç¬¦ä¸² s ä¸­çš„æŸäº›å­—ç¬¦å®ç°ã€‚

ä¾‹å¦‚ï¼Œ"abc" æ˜¯ "aebdc" çš„å­åºåˆ—ï¼Œå› ä¸ºæ‚¨å¯ä»¥åˆ é™¤"aebdc"ä¸­çš„ä¸‹åˆ’çº¿å­—ç¬¦æ¥å¾—åˆ° "abc" ã€‚"aebdc"çš„å­åºåˆ—è¿˜åŒ…æ‹¬"aebdc"ã€ "aeb" å’Œ "" (ç©ºå­—ç¬¦ä¸²)ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/longest-uncommon-subsequence-ii





```c++
class Solution {
public:
/*
    åŒé‡å¾ªç¯ï¼Œåˆ¤æ–­æ¯ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æŸä¸ªå­—ç¬¦ä¸²çš„å­åºåˆ—ã€‚
*/
    bool IsCom(string &a,string &b)//é»˜è®¤bä¸ºé•¿çš„åºåˆ—ï¼Œåˆ¤æ–­aæ˜¯å¦ä¸ºbçš„å­åºåˆ—
    {
        int i=0,j=0,cnt=0;
        while(a[i]!='\0'&&b[j]!='\0')
        {
            if(a[i]==b[j])
            {
                cnt++;
                i++;
                j++;
            }
            else j++;
        }
        return i>=a.size();
    }
    int findLUSlength(vector<string>& strs) {
        int res=-1,max=-1;
        for(int i=0;i<strs.size();++i)
        {
            int falg=1;
            for(int j=0;j<strs.size();++j)
            {
                if(i==j)continue;
                else 
                {
                    if(IsCom(strs[i],strs[j]))falg=0;
                }
            }
            if(falg==1)
            {
                res=strs[i].size();
                max=res>max?res:max;
            }
        }
        return max;
    }
};
```



# å“ˆå¸Œè¡¨

### 1.èµé‡‘ä¿¡(ç®€å•)

ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼šransomNote å’Œ magazine ï¼Œåˆ¤æ–­ ransomNote èƒ½ä¸èƒ½ç”± magazine é‡Œé¢çš„å­—ç¬¦æ„æˆã€‚

å¦‚æœå¯ä»¥ï¼Œè¿”å› true ï¼›å¦åˆ™è¿”å› false ã€‚

magazine ä¸­çš„æ¯ä¸ªå­—ç¬¦åªèƒ½åœ¨ ransomNote ä¸­ä½¿ç”¨ä¸€æ¬¡ã€‚
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/ransom-note



æ€è·¯ï¼šå“ˆå¸Œè¡¨å®ç°

â€‹          1.å¦‚æœransomnoteå¤§äºmagazineï¼Œä¸å¯èƒ½æ„æˆã€‚

â€‹       	2.å°†magazineä¸­æ‰€æœ‰å­—æ¯è¿›è¡Œéå†ï¼Œè®°å½•å‡ºç°æ¬¡æ•°ï¼Œå†éå†ransomnoteä¸­ï¼Œå¦‚æœå°äº0åˆ™falseã€‚

```c
bool canConstruct(char * ransomNote, char * magazine){
    int hashtab[26]={0};
    if(strlen(ransomNote)>strlen(magazine))return false;
    for(int i=0;i<strlen(magazine);++i) ++hashtab[magazine[i]-'a'];
    for(int i=0;i<strlen(ransomNote);++i)--hashtab[ransomNote[i]-'a'];
    for(int i=0;i<26;++i)if(hashtab[i]<0)return false;
    return true;
}
```

### 2.æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯(ç®€å•)

ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ t ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­ t æ˜¯å¦æ˜¯ s çš„å­—æ¯å¼‚ä½è¯ã€‚

æ³¨æ„ï¼šè‹¥ s å’Œ t ä¸­æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°éƒ½ç›¸åŒï¼Œåˆ™ç§° s å’Œ t äº’ä¸ºå­—æ¯å¼‚ä½è¯ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/valid-anagram

æ€è·¯ï¼šåŒä¸Š

```c
bool isAnagram(char * s, char * t){
    if(strlen(s)!=strlen(t))return false;
    int hashtab[26]={0};
    for(int i=0;i<strlen(s);++i)++hashtab[s[i]-'a'];
    for(int i=0;i<strlen(s);++i)--hashtab[t[i]-'a'];
    for(int i=0;i<26;++i)if(hashtab[i]!=0)return false;
    return true;
}
```

### 3.ç¯å½¢é“¾è¡¨(ç®€å•)

ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œåˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦æœ‰ç¯ã€‚

å¦‚æœé“¾è¡¨ä¸­æœ‰æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡è¿ç»­è·Ÿè¸ª next æŒ‡é’ˆå†æ¬¡åˆ°è¾¾ï¼Œåˆ™é“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œè¯„æµ‹ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨æ•´æ•° pos æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚æ³¨æ„ï¼špos ä¸ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’ ã€‚ä»…ä»…æ˜¯ä¸ºäº†æ ‡è¯†é“¾è¡¨çš„å®é™…æƒ…å†µã€‚

å¦‚æœé“¾è¡¨ä¸­å­˜åœ¨ç¯ ï¼Œåˆ™è¿”å› true ã€‚ å¦åˆ™ï¼Œè¿”å› false ã€‚

 

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/linked-list-cycle

æ€è·¯ï¼šå¿«æ…¢æŒ‡é’ˆï¼Œä¸€å—ä¸€æ…¢ï¼Œå¦‚æœç›¸é‡åˆ™ä¸ºç¯ã€‚

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
bool hasCycle(struct ListNode *head) {
    if(head==NULL||head->next==NULL)return false;
    struct ListNode*low=head;
    struct ListNode*fast=head->next;
    while(low!=fast){
        if(fast==NULL||fast->next==NULL)return false;
        low=low->next;
        fast=fast->next->next;
    }
    return true;
}
```

**å¿ƒå¾—ï¼šåœ¨åˆ¤æ–­æ¡ä»¶è€æ˜¯å‡ºç°é—®é¢˜ï¼Œå¿«æ…¢æŒ‡é’ˆåˆ¤æ–­æ¡ä»¶åªéœ€è¦åˆ¤æ–­å¿«æŒ‡é’ˆå°±è¡Œã€‚**

### 4.æœ‰æ•ˆçš„æ•°ç‹¬(ä¸­ç­‰)

è¯·ä½ åˆ¤æ–­ä¸€ä¸ª 9 x 9 çš„æ•°ç‹¬æ˜¯å¦æœ‰æ•ˆã€‚åªéœ€è¦ æ ¹æ®ä»¥ä¸‹è§„åˆ™ ï¼ŒéªŒè¯å·²ç»å¡«å…¥çš„æ•°å­—æ˜¯å¦æœ‰æ•ˆå³å¯ã€‚

æ•°å­— 1-9 åœ¨æ¯ä¸€è¡Œåªèƒ½å‡ºç°ä¸€æ¬¡ã€‚
æ•°å­— 1-9 åœ¨æ¯ä¸€åˆ—åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚
æ•°å­— 1-9 åœ¨æ¯ä¸€ä¸ªä»¥ç²—å®çº¿åˆ†éš”çš„ 3x3 å®«å†…åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚ï¼ˆè¯·å‚è€ƒç¤ºä¾‹å›¾ï¼‰


æ³¨æ„ï¼š

ä¸€ä¸ªæœ‰æ•ˆçš„æ•°ç‹¬ï¼ˆéƒ¨åˆ†å·²è¢«å¡«å……ï¼‰ä¸ä¸€å®šæ˜¯å¯è§£çš„ã€‚
åªéœ€è¦æ ¹æ®ä»¥ä¸Šè§„åˆ™ï¼ŒéªŒè¯å·²ç»å¡«å…¥çš„æ•°å­—æ˜¯å¦æœ‰æ•ˆå³å¯ã€‚
ç©ºç™½æ ¼ç”¨ '.' è¡¨ç¤ºã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/valid-sudoku

æ€è·¯ï¼šç¬¨åŠæ³•ï¼Œæ¯ä¸ªæ•°ç»„éƒ½å¾ªç¯ç”¨å“ˆå¸Œè¡¨å­˜ä¸€è¾¹å¹¶åˆ¤æ–­

```c
bool isValidSudoku(char** board, int boardSize, int* boardColSize){
    //åˆ¤æ–­è¡Œåˆ—
    for(int i=0;i<boardSize;++i){
        int hashtab1[9]={0};
        int hashtab2[9]={0};
        for(int j=0;j<boardSize;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
                ++hashtab1[board[i][j]-'0'-1];
            }
            if(board[j][i]>='1'&&board[j][i]<='9'){
                ++hashtab2[board[j][i]-'0'-1];
            }
        }
        for(int k=0;k<boardSize;++k){
            if(hashtab1[k]>1)return false;
            if(hashtab2[k]>1)return false;
        }
    }
    //åˆ¤æ–­ä¹å®«æ ¼
    //1
    int hashtab[9]={0};
    for(int i=0;i<3;++i){
        for(int j=0;j<3;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //2
    for(int i=3;i<6;++i){
        for(int j=0;j<3;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //3
    for(int i=6;i<9;++i){
        for(int j=0;j<3;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //4 
    for(int i=0;i<3;++i){
        for(int j=3;j<6;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //5
    for(int i=3;i<6;++i){
        for(int j=3;j<6;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //6
    for(int i=6;i<9;++i){
        for(int j=3;j<6;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //7
    for(int i=0;i<3;++i){
        for(int j=6;j<9;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //8
    for(int i=3;i<6;++i){
        for(int j=6;j<9;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //9
    for(int i=6;i<9;++i){
        for(int j=6;j<9;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    return true;
}
```

**è­¦ç¤º:åˆ«å¿˜äº†charä¸­æ•°å­—å’Œintä¸­æ•°å­—ä¸ä¸€æ ·ï¼è¦ç”¨æ•°ç»„ä¸‹æ ‡æ¥å­˜ï¼Œå¾—å‡å»æ•°å­—ï¼Œæ¯”å¦‚'0'çš„asciiç ä¸º48ï¼Œè¦å­˜å¾—å‡å»'0'çš„48å˜ä¸ºæ•°å­—0ã€‚**

### 5.ä¸¤æ•°ä¹‹å’Œ(ç®€å•)

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ target  çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ åœ¨ç­”æ¡ˆé‡Œä¸èƒ½é‡å¤å‡ºç°ã€‚

ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/two-sum



æ€è·¯ï¼š1.æš´åŠ›æ³•ï¼Œä¸¤å±‚å¾ªç¯

â€‹			2.å“ˆå¸Œè¡¨ï¼šåœ¨å­˜å…¥çš„åŒæ—¶è¿›è¡Œä¸€ä¸ªæŸ¥ç…§ã€‚

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
/*
åˆ›å»ºå“ˆå¸Œè¡¨ï¼Œå°†æ•°ç»„å­˜å…¥ï¼Œè¾¹å­˜å…¥è¾¹æŸ¥ç…§ã€‚
*/
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    *returnSize=2;
    int *a=malloc(sizeof(int)*2);
    int hashtab[numsSize];
    for(int i=0;i<numsSize;++i){
        for(int j=0;j<i;++j){
            if(nums[hashtab[j]]==target-nums[i]){
                a[0]=hashtab[j];
                a[1]=i;
                return a;
            }
        }
        hashtab[i]=i;   
    }
    return NULL;
}
```

### 6.æ— é‡å¤æœ€é•¿å­—ç¬¦å­—ä¸²(ä¸­ç­‰)

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `s` ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„ **æœ€é•¿å­ä¸²** çš„é•¿åº¦ã€‚



è¾“å…¥: s = "pwwkew"
è¾“å‡º: 3
è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "wke"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚
     è¯·æ³¨æ„ï¼Œä½ çš„ç­”æ¡ˆå¿…é¡»æ˜¯ å­ä¸² çš„é•¿åº¦ï¼Œ"pwke" æ˜¯ä¸€ä¸ªå­åºåˆ—ï¼Œä¸æ˜¯å­ä¸²ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/longest-substring-without-repeating-characters



```c
/*
å“ˆå¸Œè¡¨ä¸ä¼š
æ»‘åŠ¨çª—å£ æ€è·¯æ˜¯ä¸€æ ·çš„
æ€è·¯ï¼šleftå’Œrightï¼Œå¯»æ‰¾æ–°å…ƒç´ ï¼Œéå†æ—§å…ƒç´ ï¼Œå¦‚æœæœ‰ç›¸åŒå°±è®©leftå˜ä¸ºä»€ä¹ˆï¼Ÿï¼Ÿè®°å½•æœ€å¤§å€¼ã€‚
*/
int lengthOfLongestSubstring(char * s){
    int len=strlen(s);
    if(len==0||len==1)return len;
    int left=0,right=0,max=0;//å®šä¹‰å·¦çª—å£å’Œå³çª—å£
    while(s[right+1]!='\0'){
        right++;
        for(int i=left;i<right;++i){//åˆ¤æ–­æ˜¯å¦æœ‰é‡å¤å…ƒç´ ï¼Œå¦‚æœæœ‰åˆ™å°†å·¦çª—å£ç§»è‡³é‡å¤å…ƒç´ ä¹‹å
            if(s[i]==s[right]){
                left=i+1;
                break;
            }
        }
        if(right-left+1>max)max=right-left+1;
    }
    return max;
}
```





### 7.æŸ¥ç…§å…¬ç”¨å­—ç¬¦(ç®€å•...)



1002

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šwords = ["bella","label","roller"]
è¾“å‡ºï¼š["e","l","l"]
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šwords = ["cool","lock","cook"]
è¾“å‡ºï¼š["c","o"]



```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 /*
    æ€è·¯ï¼šå“ˆå¸Œè¡¨å­˜å‚¨.
        ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨å­˜å‚¨å‡ºç°çš„æœ€å°é¢‘ç‡
 */
char ** commonChars(char ** words, int wordsSize, int* returnSize){
    //ç»Ÿè®¡ç¬¬ä¸€ä¸²å­—ç¬¦å‡ºç°é¢‘ç‡
    int hash[26]={0};
    for(int i=0;i<strlen(words[0]);++i){
        hash[words[0][i]-'a']++;
    }

    //ç»Ÿè®¡å…¶ä½™å­—ç¬¦ä¸²å‡ºç°é¢‘ç‡
    
    for(int i=1;i<wordsSize;++i){
        int hashother[26]={0};//æ¯æ¬¡éƒ½æ›´æ–°
        for(int j=0;j<strlen(words[i]);++j){
            hashother[words[i][j]-'a']++;
        }
        //åˆ·æ–°hash
        for(int k=0;k<26;++k)
            hash[k]=hash[k]>hashother[k]?hashother[k]:hash[k];

    }
    //æ±‚åˆ†é…çš„ç©ºé—´
    int sum=0;
    for(int i=0;i<26;i++)sum+=hash[i];




    //è¾“å‡º
    *returnSize=0;
    char **result=malloc(sizeof(char*)*sum);
    for(int j=0;j<26;++j){
        while(hash[j]!=0){
            result[*returnSize]=malloc(sizeof(char)*2);
            result[*returnSize][0]=j+'a';
            result[*returnSize][1]='\0';//è¿™ä¸ªåœ°æ–¹è®©æˆ‘å¥½æ‰¾ï¼Œçœ‹åˆ°åŠ›æ‰£å®˜æ–¹é¢˜è§£èµ‹å€¼ä¸º0ï¼Œç„¶åç–¯ç‹‚æŠ¥é”™è¶Šç•Œ
            hash[j]--;
            (*returnSize)++;
        }
    }
    return result;
}
```



### 8.ä¸¤æ•°ä¹‹å’Œ IV - è¾“å…¥ BST(simple)





ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘ `root` å’Œä¸€ä¸ªç›®æ ‡ç»“æœ `k`ï¼Œå¦‚æœ BST ä¸­å­˜åœ¨ä¸¤ä¸ªå…ƒç´ ä¸”å®ƒä»¬çš„å’Œç­‰äºç»™å®šçš„ç›®æ ‡ç»“æœï¼Œåˆ™è¿”å› `true`ã€‚



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/*
    å“ˆå¸Œè¡¨ +ä¸¤æ•°ä¹‹å’Œ
*/
void bintraverse(struct TreeNode *root,int *hash,int *j){
    //å‰åºéå†
    if(root){
        hash[(*j)++]=root->val;
        bintraverse(root->left,hash,j);
        bintraverse(root->right,hash,j);
    }
}
int comp(const void*a,const void*b){
    return *(int*)a-*(int*)b;
}
bool findTarget(struct TreeNode* root, int k){
    int hash[10000];
    int j=0;
    bintraverse(root,hash,&j);
    //æ’åº
    qsort(hash,j,sizeof(int),comp);
    //åŒæŒ‡é’ˆ
    int left=0,right=j-1;
    //for(int i=0;i<j;++i)printf("%d ",hash[i]);
    while(right<=j-1&&left<right){
        if(hash[left]+hash[right]==k)return true;
        else if(hash[left]+hash[right]<k)left++;
        else if(hash[left]+hash[right]>k)right--;
    }
    return false;
}
```







# æ ˆå’Œé˜Ÿåˆ—

### 1.æœ‰æ•ˆçš„æ‹¬å·(ç®€å•)

ç»™å®šä¸€ä¸ªåªåŒ…æ‹¬ '('ï¼Œ')'ï¼Œ'{'ï¼Œ'}'ï¼Œ'['ï¼Œ']' çš„å­—ç¬¦ä¸² s ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆã€‚

æœ‰æ•ˆå­—ç¬¦ä¸²éœ€æ»¡è¶³ï¼š

å·¦æ‹¬å·å¿…é¡»ç”¨ç›¸åŒç±»å‹çš„å³æ‹¬å·é—­åˆã€‚
å·¦æ‹¬å·å¿…é¡»ä»¥æ­£ç¡®çš„é¡ºåºé—­åˆã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/valid-parentheses

æ€è·¯ï¼šç®€å•æ ˆåº”ç”¨

â€‹        å¦‚æœä¸ºå·¦æ‹¬å·åˆ™å…¥æ ˆï¼Œå³æ‹¬å·çœ‹æ˜¯å¦ä¸æ ˆå†…ç›¸åŒ¹é…ï¼ŒåŒ¹é…åˆ™å‡ºæ ˆï¼Œä¸ç„¶å°±false

â€‹        å½“å¾ªç¯å®Œåï¼Œå¦‚æœæ ˆå†…æ²¡æœ‰åˆ™true

```c
bool isValid(char * s){
    if(strlen(s)==0)return false;
    char a[10000]={0};
    int j=1;
    for(int i=0;i<strlen(s);++i){
        if(s[i]=='('||s[i]=='['||s[i]=='{')a[j++]=s[i];//å…¥æ ˆ
        else if(s[i]==')'||s[i]==']'||s[i]=='}'){   //é…å¯¹å¹¶å‡ºæ ˆ
            if(s[i]==')'&&a[j-1]=='('||s[i]==']'&&a[j-1]=='['||s[i]=='}'&&a[j-1]=='{')a[--j]=0; 
            else return false;
        }   
    }
        if(a[1]==0)return true;
        else return false;
}
```



### 2.åˆ é™¤æ‰€æœ‰ç›¸é‚»å…ƒç´ é¡¹(ç®€å•)



è¾“å…¥ï¼š"abbaca"
è¾“å‡ºï¼š"ca"
è§£é‡Šï¼š
ä¾‹å¦‚ï¼Œåœ¨ "abbaca" ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åˆ é™¤ "bb" ç”±äºä¸¤å­—æ¯ç›¸é‚»ä¸”ç›¸åŒï¼Œè¿™æ˜¯æ­¤æ—¶å”¯ä¸€å¯ä»¥æ‰§è¡Œåˆ é™¤æ“ä½œçš„é‡å¤é¡¹ã€‚ä¹‹åæˆ‘ä»¬å¾—åˆ°å­—ç¬¦ä¸² "aaca"ï¼Œå…¶ä¸­åˆåªæœ‰ "aa" å¯ä»¥æ‰§è¡Œé‡å¤é¡¹åˆ é™¤æ“ä½œï¼Œæ‰€ä»¥æœ€åçš„å­—ç¬¦ä¸²ä¸º "ca"ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string



```
char * removeDuplicates(char * s){
    char *stack=(char*)malloc(sizeof(char)*(strlen(s)+1));
    int j=0;
    for(int i=0;i<strlen(s);++i){
        //ç›¸ç­‰å°±å‡ºæ ˆ
        if(j>0&&s[i]==stack[j-1]){
            j--;
        }
        //ä¸ç›¸ç­‰å…¥æ ˆ
        else
        stack[j++]=s[i];
    }
    stack[j]='\0';
    return stack;
}
```





### 3.é€†æ³¢å…°è¡¨è¾¾å¼(medium)



```
Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
```



```
int a(char * b){
    int sum=0,i=0;
    int sign=1;
    if(*b=='-'){
        sign=-1;
        b++;
    }
    for(i=0;b[i]!='\0';++i){
        if(b[i]>='0'&&b[i]<='9'){
            sum=sum*10+b[i]-'0';
        }
    }
    return sum*sign;
}
int evalRPN(char ** tokens, int tokensSize){
    //å»ºç«‹æ ˆ
    int pro[tokensSize];
    int j=0;
    for(int i=0;i<tokensSize;++i){
        char *token=tokens[i];
        //æ˜¯æ•°å­—å°±å…¥æ ˆ
        if(token[0]>='0' &&token[0]<= '9'||strlen(token)>1){
            pro[j++]=a(token);
            //printf("%d  ",pro[j-1]);
        }
        //ç¬¦å·å‡ºæ ˆåšè¿ç®—
        else if(token[0]=='+'||token[0]=='-'||token[0]=='*'||token[0]=='/'){
            int sum1=pro[--j];
            int sum2=pro[--j];
            //printf("%d %d  ",sum1,sum2);
            if(token[0]=='+')pro[j++]=sum1+sum2;
            else if(token[0]=='-')pro[j++]=-sum1+sum2;
            else if(token[0]=='*')pro[j++]=sum1*sum2;
            else pro[j++]=sum2/sum1;
        }
    }
    int ans=pro[0];
    return ans;
}
```





### 4.æ±‚æ»‘åŠ¨çª—å£æœ€å¤§å€¼(difficult)



```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 /*
    é˜Ÿåˆ—ï¼Œæ¯æ¬¡ç»´æŠ¤ä¸€ä¸ªæœ€å¤§å€¼
    å…ˆå°†å‰kä¸ªæ•°æ”¾å…¥æ ˆä¸­
        è§„åˆ™ï¼š
        1 å¦‚æœå‹å…¥å…ƒç´ å¤§äºå¤´å…ƒç´ ï¼Œåˆ™è®©æ‰€æœ‰å…ƒç´ å‡ºæ ˆï¼Œè¯¥å…ƒç´ ä¸ºå¤´å…ƒç´ 
        2 å¦‚æœå…¥é˜Ÿå…ƒç´ å¤§äºé˜Ÿå°¾å…ƒç´ å°±è®©é˜Ÿå°¾ä¾æ¬¡å‡ºé˜Ÿï¼Œç»´æŠ¤å•è°ƒé€’å‡é˜Ÿåˆ—
        3 æ¯æ¬¡éƒ½è®°å½•é˜Ÿåˆ—å¤´ 
    ä¸ºä»€ä¹ˆè¦å­˜ä¸‹æ ‡ï¼Ÿ
        é¦–å…ˆï¼Œå†æ•°ç»„ä¸­ç”±ä¸‹æ ‡æ‰¾æ•°æ–¹ä¾¿ï¼Œä½†æ˜¯ç”±æ•°æ‰¾ä¸‹æ ‡å¾ˆéš¾ï¼Œå­˜ä¸‹æ ‡æ–¹æ ‡çŸ¥é“é‚£ä¸ªå…ƒç´ åº”è¯¥å‡ºé˜Ÿã€‚
        ä½†æ˜¯ï¼Œå¦‚æœç›´æ¥å­˜æœ€å¤§å…ƒç´ ï¼Œå°±æ— æ³•çŸ¥é“ä»€ä¹ˆæ—¶å€™é‚£ä¸ªæ˜¯æœ€å¤§å…ƒç´ ï¼Œä»€ä¹ˆæ—¶å€™åº”è¯¥å‡ºé˜Ÿã€‚
 */
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    //æ’é™¤
    *returnSize=numsSize;
    if(numsSize==0||k<2)return nums;

    int *ans=(int*)malloc(sizeof(int)*numsSize);
    *returnSize=numsSize-k+1;
    int left=0,right=0;
    //æ¨¡æ‹Ÿé˜Ÿåˆ—
    int queue[numsSize];
    int i=0;
    while(i<numsSize){
        //æ¯æ¬¡çª—å£æ‰«è¿‡å°±å‡ºé˜Ÿå¤´å…ƒç´ 
        while(left<right&&queue[left]<i-k+1)left++;
        //ç»´æŠ¤å•è°ƒé˜Ÿåˆ—
        while(left<right&&nums[queue[right-1]]<nums[i])right--;
        //å…¥é˜Ÿ
        queue[right++]=i;
        if(i>=k-1)ans[i-k+1]=nums[queue[left]];
        i++;
    }
    return ans;
}
```







# åŒæŒ‡é’ˆ

### 1.ä¸‰æ•°ä¹‹å’Œ(ä¸­ç­‰)

ç»™ä½ ä¸€ä¸ªåŒ…å« n ä¸ªæ•´æ•°çš„æ•°ç»„ numsï¼Œåˆ¤æ–­ nums ä¸­æ˜¯å¦å­˜åœ¨ä¸‰ä¸ªå…ƒç´  aï¼Œbï¼Œc ï¼Œä½¿å¾— a + b + c = 0 ï¼Ÿè¯·ä½ æ‰¾å‡ºæ‰€æœ‰å’Œä¸º 0 ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚

æ³¨æ„ï¼šç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„ä¸‰å…ƒç»„ã€‚

 

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/3sum

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
 /*
 æ€è·¯ï¼šåŒæŒ‡é’ˆ
    æŒ‡é’ˆleft=iï¼Œright=numsSize-1
    å¦‚æœä¸‰æ•°å’Œå¤§äº0åˆ™right--ï¼Œå°äº0åˆ™left++
    åˆ«å¿˜äº†å»é‡ï¼ˆå…³é”®ï¼‰
 */
 int comp(void*a,void*b){
     return *(int *)a-*(int *)b;
 }
int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    *returnSize=0;
    if(numsSize<3)return NULL;

    qsort(nums,numsSize,sizeof(int),comp);

    int **a=malloc(sizeof(int*)*numsSize*numsSize);//åˆ›å»ºè¿”å›æ•°ç»„

    *returnColumnSizes=(int*)malloc(sizeof(int*)*numsSize*numsSize);
    *returnSize=0;

    for(int i=0;i<numsSize;++i){
        //å·²ç»æ’åºï¼Œç¬¬ä¸€ä¸ªå¤§äº0ç›´æ¥é€€å‡º
        if(nums[i]>0)break;
        //å»é‡
        if(i>0&&nums[i]==nums[i-1])continue;
        //å®šä¹‰å·¦å³æŒ‡é’ˆ
        int left=i+1;
        int right=numsSize-1;
        while(left<right){
            int sum=nums[i]+nums[left]+nums[right];
            if(sum==0){
                a[*returnSize]=(int*)malloc(sizeof(int)*3);
                a[*returnSize][0]=nums[i];
                a[*returnSize][1]=nums[left];
                a[*returnSize][2]=nums[right];
                (*returnColumnSizes)[*returnSize]=3;
                (*returnSize)++;
                //å¯¹å·¦å³æŒ‡é’ˆå»é‡
                while(left<right&&nums[left]==nums[++left]);
                while(left<right&&nums[right]==nums[--right]);
            }
            else if(sum>0)right--;
            else left++;
        }

    }
    return a;
    
}
```

**ä¹Ÿè®¸æœ‰äº›é¢˜å¹¶ä¸æ˜¯é‚£ä¹ˆéš¾ï¼Œåªæ˜¯è‡ªå·±å†™ä»£ç çš„èƒ½åŠ›å¤ªå¼±äº†ï¼Œè¿˜éœ€è¦å¤šåŠ ç»ƒä¹ ï¼Œä¹Ÿè®¸ç”Ÿæ´»å°±æ˜¯è¿™æ ·å§ï¼Œä¸Šå¤©è‡ªç„¶ä¸ä¼šäºå¾…äº†è°ï¼ŒåŠªåŠ›ç»ˆç©¶ä¼šæœ‰å›æŠ¥ï¼Œæ•¢äºé¢å¯¹ç”Ÿæ´»ä¸­çš„ä¸€äº›å›°éš¾ï¼Œåªæœ‰å‹‡æ•¢çš„é¢å¯¹ï¼Œæ‰ä¼šæœ‰ç¾å¥½çš„å°†æ¥ã€‚**

### 2.ç››æ°´æœ€å¤šçš„å®¹å™¨(ä¸­ç­‰)

ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•´æ•°æ•°ç»„ height ã€‚æœ‰ n æ¡å‚çº¿ï¼Œç¬¬ i æ¡çº¿çš„ä¸¤ä¸ªç«¯ç‚¹æ˜¯ (i, 0) å’Œ (i, height[i]) ã€‚

æ‰¾å‡ºå…¶ä¸­çš„ä¸¤æ¡çº¿ï¼Œä½¿å¾—å®ƒä»¬ä¸ x è½´å…±åŒæ„æˆçš„å®¹å™¨å¯ä»¥å®¹çº³æœ€å¤šçš„æ°´ã€‚

è¿”å›å®¹å™¨å¯ä»¥å‚¨å­˜çš„æœ€å¤§æ°´é‡ã€‚

è¯´æ˜ï¼šä½ ä¸èƒ½å€¾æ–œå®¹å™¨ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/container-with-most-water



```c
/*
    æ€è·¯ï¼šæš´åŠ›æ±‚è§£
            å¾ªç¯éå†ï¼Œæ¯æ¬¡è®°å½•æœ€å¤§æ°´é‡
            .....è¶…æ—¶äº†
          åŒæŒ‡é’ˆ
            å·¦æŒ‡é’ˆå’Œå³æŒ‡é’ˆï¼Œæ¯æ¬¡è®°å½•æœ€å¤§æ°´é‡
            ç§»åŠ¨æ•°å­—å°çš„æŒ‡é’ˆ

        ä¸ºä»€ä¹ˆç§»åŠ¨æ•°å­—å°çš„æŒ‡é’ˆï¼Ÿ
            æ°´é‡=å°æ•°å­— Ã— ä¸¤æŒ‡é’ˆä¹‹å·®
            å¦‚æœç§»åŠ¨å¤§æ•°å­—ï¼Œåˆ™å°çš„æ•°å­—å¯èƒ½ä¸å˜ï¼Œä½†ä¸¤æŒ‡é’ˆä¹‹å·®å˜äº†ï¼Œæ°´é‡å‡å°‘ã€‚
*/
int maxArea(int* height, int heightSize){
    int left=0,right=heightSize-1;
    int max=0;
    while(left<right){
        //ç®—å‡ºæ°´é‡
        int water=(right-left) * (height[left]>height[right]?height[right--]:height[left++]);
        if(water>max)max=water;
    }
    return max;
}
```



### 3.æ°´æœç¯®å­(ä¸­ç­‰)



æ‚¨æ­£åœ¨å‚è§‚ä¸€ä¸ªå†œåœºï¼Œè¯¥å†œåœºæœ‰ä¸€æ’ä»å·¦åˆ°å³æ’åˆ—çš„æœæ ‘ã€‚æ ‘ç”±æ•´æ•°æ•°ç»„fruitsè¡¨ç¤ºï¼Œå…¶ä¸­æ°´æœ[i]æ˜¯ç¬¬iæ£µæ ‘äº§ç”Ÿçš„æ°´æœç±»å‹ã€‚ ä½ æƒ³æ”¶é›†å°½å¯èƒ½å¤šçš„æ°´æœã€‚ä½†æ˜¯ï¼Œæ‰€æœ‰è€…æœ‰ä¸€äº›ä¸¥æ ¼çš„è§„åˆ™ï¼Œæ‚¨å¿…é¡»éµå®ˆï¼š ä½ åªæœ‰ä¸¤ä¸ªç¯®å­ï¼Œæ¯ä¸ªç¯®å­åªèƒ½è£…ä¸€ç§æ°´æœã€‚æ¯ç¯®æ°´æœçš„æ•°é‡æ²¡æœ‰é™åˆ¶ã€‚ ä»æ‚¨é€‰æ‹©çš„ä»»ä½•ä¸€æ£µæ ‘å¼€å§‹ï¼Œæ‚¨å¿…é¡»åœ¨å‘å³ç§»åŠ¨æ—¶ä»æ¯æ£µæ ‘ï¼ˆåŒ…æ‹¬èµ·å§‹æ ‘ï¼‰ä¸­æ°å¥½æ‘˜ä¸‹ä¸€ä¸ªæ°´æœ,æ‘˜ä¸‹çš„æ°´æœå¿…é¡»æ”¾åœ¨ä½ çš„ä¸€ä¸ªç¯®å­é‡Œã€‚ ä¸€æ—¦ä½ åˆ°äº†ä¸€æ£µæ ‘ä¸Šï¼Œæ ‘ä¸Šçš„æœå®æ²¡æ³•æ”¾å…¥ä½ çš„ç¯®å­ï¼ˆä¸¤ä¸ªç¯®å­å·²ç»æ»¡äº†ï¼‰ï¼Œä½ å¿…é¡»åœä¸‹æ¥ã€‚ ç»™å®šæ•´æ•°æ•°ç»„æ°´æœï¼Œè¿”å›å¯ä»¥æ‹¾å–çš„æœ€å¤§æ°´æœæ•°ã€‚ æœ¬é¢˜ï¼Œå…¶å®å°±æ˜¯é€‰åªæœ‰ä¸¤ä¸ªå…ƒç´ çš„æœ€é•¿è¿ç»­å­åºåˆ—ï¼Œæ¯”å¦‚1ï¼Œ2ï¼Œ3ï¼Œ2ï¼Œ2æœ€é•¿å°±æ˜¯2ï¼Œ3ï¼Œ2ï¼Œ2ï¼ˆåªåŒ…æ‹¬2æˆ–è€…3ï¼Œè€Œä¸”æ˜¯æœ€é•¿çš„ï¼‰ã€‚



ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šfruits = [1,2,1]
è¾“å‡ºï¼š3
è§£é‡Šï¼šå¯ä»¥é‡‡æ‘˜å…¨éƒ¨ 3 æ£µæ ‘ã€‚
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šfruits = [0,1,2,2]
è¾“å‡ºï¼š3
è§£é‡Šï¼šå¯ä»¥é‡‡æ‘˜ [1,2,2] è¿™ä¸‰æ£µæ ‘ã€‚
å¦‚æœä»ç¬¬ä¸€æ£µæ ‘å¼€å§‹é‡‡æ‘˜ï¼Œåˆ™åªèƒ½é‡‡æ‘˜ [0,1] è¿™ä¸¤æ£µæ ‘ã€‚
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šfruits = [1,2,3,2,2]
è¾“å‡ºï¼š4
è§£é‡Šï¼šå¯ä»¥é‡‡æ‘˜ [2,3,2,2] è¿™å››æ£µæ ‘ã€‚
å¦‚æœä»ç¬¬ä¸€æ£µæ ‘å¼€å§‹é‡‡æ‘˜ï¼Œåˆ™åªèƒ½é‡‡æ‘˜ [1,2] è¿™ä¸¤æ£µæ ‘ã€‚
ç¤ºä¾‹ 4ï¼š

è¾“å…¥ï¼šfruits = [3,3,3,1,2,1,1,2,3,3,4]
è¾“å‡ºï¼š5
è§£é‡Šï¼šå¯ä»¥é‡‡æ‘˜ [1,2,1,1,2] è¿™äº”æ£µæ ‘ã€‚



```c
int totalFruit(int* fruits, int fruitsSize){
    int left=0,right=0,ans=0;
    int ln=fruits[left],rn=fruits[right];//ä¸¤ä¸ªç¯®å­
    while(right<fruitsSize){
        if(fruits[right]==ln||fruits[right]==rn){
            ans=ans>(right-left+1)?ans:(right-left+1);
            right++;//æ‰¾åˆ°ç›¸åŒçš„ç»§ç»­å‘å³æ‰¾
        }
        else {//å°†å·¦è“å­ç§»åŠ¨åˆ°å³ç¯®å­å‰ä¸€ä¸ªï¼Œå¿…å®šä¸ç›¸åŒï¼Œç»§ç»­å‘å‰æ‰¾
            left=right-1;
            ln=fruits[left];
            while(left>0&&fruits[left-1]==ln)left--;
            ans=ans>(right-left+1)?ans:(right-left+1);
            rn=fruits[right];
        }
    }
    return ans;
}
```



### 4.ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†(ç®€å•)

æ‰¾å‡ºä¸¤ä¸ªæ•°ç»„ä¸­ç›¸åŒçš„æ•°å¹¶å»é‡



```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 //æ’åºåŠ åŒæŒ‡é’ˆ
 int comp(void*a,void*b){
     return *(int*)a-*(int*)b;
 }
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    qsort(nums1,nums1Size,sizeof(int),comp);
    qsort(nums2,nums2Size,sizeof(int),comp);
    int a=0,b=0;
    int j=0;
    int *result=malloc(sizeof(int*)*(nums1Size+nums2Size));
    while(a<nums1Size&&b<nums2Size){
        if(nums1[a]>nums2[b])b++;
        else if(nums1[a]<nums2[b])a++;
        else {
            result[j++]=nums1[a];
            a++;
            b++;
            if(j>1&&result[j-1]==result[j-2])j--;//ç›¸ç­‰åˆ™ä¸‹æ ‡åç§»ï¼Œä¼šè¦†ç›–ã€‚
        }
    }
    *returnSize=j;
    return result;
}
```



### 5.åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªç»“ç‚¹(ä¸­ç­‰)

åŠ›æ‰£19é¢˜

ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ `n` ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”è¿”å›é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚



```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

/*
åŒæŒ‡é’ˆæ³•ï¼Œå…ˆè®©å¿«æŒ‡é’ˆèµ°næ­¥ï¼Œç„¶åå¿«æ…¢æŒ‡é’ˆä¸€èµ·èµ°ã€‚
*/
struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    struct ListNode*virtual=malloc(sizeof(struct ListNode));
    virtual->next=head;
    struct ListNode *low=virtual,*fast=virtual;
    while(n>0){
        fast=fast->next;
        n--;
    }
    while(fast->next){
        fast=fast->next;
        low=low->next;
    }
    fast=low->next;
    low->next=fast->next;
    free(fast);
    head=virtual->next;
    free(virtual);
    return head;
}
```





### 6.ç§»åŠ¨é›¶(ç®€å•)







```
void moveZeroes(int* nums, int numsSize){
    int i=0,j=0;
    for(i=0;i<numsSize;++i){
        if(nums[i]!=0)nums[j++]=nums[i];
    }
    while(j<numsSize)nums[j++]=0;
}
```





### 7.åè½¬æ•°ç»„(ä¸­ç­‰)

189

ç»™ä½ ä¸€ä¸ªæ•°ç»„ï¼Œå°†æ•°ç»„ä¸­çš„å…ƒç´ å‘å³è½®è½¬ `k` ä¸ªä½ç½®ï¼Œå…¶ä¸­ `k` æ˜¯éè´Ÿæ•°



```
/*
    åè½¬ä¸‰æ¬¡æ•°ç»„
*/
void reverse(int*nums,int a,int b){
    while(a<b){
        int t=nums[a];
        nums[a++]=nums[b];
        nums[b--]=t;
    }
}
void rotate(int* nums, int numsSize, int k){
    k%=numsSize;//æ•°ç»„å‘¨æœŸå˜åŒ–ï¼Œå‡å°‘æ“ä½œï¼Œè¿˜å¯ä»¥é˜²æ­¢kå¤§äºæ•°ç»„æ•°é‡
    reverse(nums,0,numsSize-1);
    reverse(nums,0,k-1);
    reverse(nums,k,numsSize-1);
}
```





### 7.æœ€å¤§è¿ç»­1çš„ä¸ªæ•°

```
/*
    åŒæŒ‡é’ˆ
    æ¯æ¬¡éƒ½è®°å½•çª—å£å†…é›¶çš„ä¸ªæ•°ï¼Œä¿è¯çª—å£å†…é›¶çš„ä¸ªæ•°å°äºç§»åŠ¨æ¬¡æ•°ï¼Œæ¯æ¬¡è®°å½•æœ€å¤§å€¼
*/
int longestOnes(int* nums, int numsSize, int k){
    int ans=0;
    int zero=0;//è®°å½•é›¶çš„ä¸ªæ•°
    int left=0,right=0;
    for(right=0;right<numsSize;++right){
        if(nums[right]==0)++zero;
        while(zero>k)if(nums[left++]==0)--zero;//ç§»åŠ¨å·¦æŒ‡é’ˆï¼Œè®©çª—å£å†…çš„é›¶çš„ä¸ªæ•°å°äºç§»åŠ¨æ¬¡æ•°
        ans=ans>(right-left+1)?ans:(right-left+1);
    }
    return ans;
}
```



### 8.è€ƒè¯•çš„æœ€å¤§å›°æ‰°åº¦

åŸç†çœ‹ä¸Šé¢˜

```
/*
    åŒæŒ‡é’ˆ æ»‘åŠ¨çª—å£
*/
int maxConsecutiveAnswers(char * answerKey, int k){
    int len=strlen(answerKey);
    int ans=0;
    int TF=0;
    int left=0,right=0;
    //æ”¹å˜T
    for(right=0;right<len;++right){
        if(answerKey[right]=='T')TF++;
        while(TF>k)if(answerKey[left++]=='T')--TF;
        ans=ans>(right-left+1)?ans:(right-left+1);
    }
    //æ”¹å˜F
    for(TF=0,left=0,right=0;right<len;++right){
        if(answerKey[right]=='F')TF++;
        while(TF>k)if(answerKey[left++]=='F')--TF;
        ans=ans>(right-left+1)?ans:(right-left+1);
    }
    return ans;
}
```



# é“¾è¡¨

### è®¾ç½®é“¾è¡¨(ä¸­ç­‰)

```c
//é“¾è¡¨å®šä¹‰
typedef struct MyLinkedListTag{
    int val;
    struct MyLinkedListTag*next;
} MyLinkedList;

//é“¾è¡¨åˆ›å»º
MyLinkedList* myLinkedListCreate() {
    MyLinkedList*head=malloc(sizeof(MyLinkedList));
    head->next=NULL;
    return head;
}
//è·å–é“¾è¡¨ä¸‹æ ‡å€¼
int myLinkedListGet(MyLinkedList* obj, int index) {
    struct MyLinkedListTag*cur=obj->next;
    for(int i=0;cur;++i){
        if(i==index){
            return cur->val;
        }
        else cur=cur->next;
    }
    return -1;
}
//å¤´æ’ 
void myLinkedListAddAtHead(MyLinkedList* obj, int val) {
    struct MyLinkedListTag*newhead=malloc(sizeof(struct MyLinkedListTag));
    newhead->val=val;
    newhead->next=obj->next;
    obj->next=newhead;
}
//å°¾æ’
void myLinkedListAddAtTail(MyLinkedList* obj, int val) {
    struct MyLinkedListTag*cur=obj;
    while(cur->next){
        cur=cur->next;
    }
    struct MyLinkedListTag*p=malloc(sizeof(struct MyLinkedListTag));
    p->next=NULL;
    p->val=val;
    cur->next=p;
}
//æ’å…¥
void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {
     //å½“idexå°äº0ï¼Œç›´æ¥è°ƒç”¨å¤´æ’
     if(index<=0){
         myLinkedListAddAtHead(obj,val);
         return;
     }
     //å½“0<idex<é“¾è¡¨é•¿åº¦
     struct MyLinkedListTag*cur=obj->next;
     for(int i=1;cur;++i){
         if(i==index){
             struct MyLinkedListTag*temp=malloc(sizeof(struct MyLinkedListTag));
             temp->val=val;
             temp->next=cur->next;
             cur->next=temp;
             return;
         }
         else cur=cur->next;
     }
}
//åˆ é™¤
void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {
    if(index==0){
        struct MyLinkedListTag*temp=obj->next;
        if(temp){//éªŒè¯æ˜¯å¦å­˜åœ¨
            obj->next=temp->next;
            free(temp);
        }
        return;
    }
    struct MyLinkedListTag*cur=obj->next;
    for(int i=1;cur&&cur->next;++i){
        if(i==index){
            struct MyLinkedListTag*temp=cur->next;
            if(temp){//éªŒè¯ä¸‹ä¸€ä¸ª
                cur->next=temp->next;
                free(temp);
            }
            return;
        }
        else cur=cur->next;
    }
}

void myLinkedListFree(MyLinkedList* obj) {
    while(obj){
        struct MyLinkedListTag*temp=obj;
        obj=obj->next;
        free(temp);
    }
}

/**
 * Your MyLinkedList struct will be instantiated and called as such:
 * MyLinkedList* obj = myLinkedListCreate();
 * int param_1 = myLinkedListGet(obj, index);
 
 * myLinkedListAddAtHead(obj, val);
 
 * myLinkedListAddAtTail(obj, val);
 
 * myLinkedListAddAtIndex(obj, index, val);
 
 * myLinkedListDeleteAtIndex(obj, index);
 
 * myLinkedListFree(obj);
*/
```



















### 1.ä¸¤æ•°ä¹‹å’Œ(ä¸­ç­‰)

ç»™ä½ ä¸¤ä¸ª éç©º çš„é“¾è¡¨ï¼Œè¡¨ç¤ºä¸¤ä¸ªéè´Ÿçš„æ•´æ•°ã€‚å®ƒä»¬æ¯ä½æ•°å­—éƒ½æ˜¯æŒ‰ç…§ é€†åº çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ ä¸€ä½ æ•°å­—ã€‚

è¯·ä½ å°†ä¸¤ä¸ªæ•°ç›¸åŠ ï¼Œå¹¶ä»¥ç›¸åŒå½¢å¼è¿”å›ä¸€ä¸ªè¡¨ç¤ºå’Œçš„é“¾è¡¨ã€‚

ä½ å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°éƒ½ä¸ä¼šä»¥ 0 å¼€å¤´ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/add-two-numbers

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

/*
    æ€è·¯ï¼šé“¾è¡¨ç›¸åŠ ï¼Œå¦‚æœå­˜åœ¨å°±ç›¸åŠ ï¼Œç”¨carryè®°å½•è¿›ä½ï¼Œä¸å­˜åœ¨å°±è®°ä¸º0.
*/
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    struct ListNode *head=NULL,*tail=NULL;//åˆå§‹åŒ–è¿”å›é“¾è¡¨
    int carry=0;
    while(l1||l2){
        int n1=l1?l1->val:0;
        int n2=l2?l2->val:0;
        int sum=n1+n2+carry;
        if(head==NULL){   //å¤´èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆå§‹åŒ–å¤´èŠ‚ç‚¹
            head=tail=malloc(sizeof(struct ListNode));
            tail->val=sum%10;
            tail->next=NULL;
        }                  //ç”¨tailï¼Œæ–¹ä¾¿è¿”å›å¤´èŠ‚ç‚¹
        else {
            tail->next=malloc(sizeof(struct ListNode));
            tail->next->val=sum%10;
            tail=tail->next;
            tail->next=NULL;
        }
        carry=sum/10;
        if(l1)l1=l1->next;//è®©l1 l2å¾€åèµ°
        if(l2)l2=l2->next;
    }
    if(carry>0){  //å¦‚æœå¤§äº0ï¼Œåˆ›é”®æ–°çš„ç»“ç‚¹æ¥å­˜æ”¾
        tail->next=malloc(sizeof(struct ListNode));
        tail->next->val=carry;
        tail->next->next=NULL;
    }
    return head;
}
```



### 2.ç§»é™¤é“¾è¡¨å…ƒç´ (ç®€å•)



ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head å’Œä¸€ä¸ªæ•´æ•° val ï¼Œè¯·ä½ åˆ é™¤é“¾è¡¨ä¸­æ‰€æœ‰æ»¡è¶³ Node.val == val çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å› æ–°çš„å¤´èŠ‚ç‚¹ ã€‚


ç¤ºä¾‹ 1ï¼š


è¾“å…¥ï¼šhead = [1,2,6,3,4,5,6], val = 6
è¾“å‡ºï¼š[1,2,3,4,5]

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/remove-linked-list-elements
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚



æ€è·¯ï¼šè®¾ç½®è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œæ–¹ä¾¿æ“ä½œ

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeElements(struct ListNode* head, int val){
    struct ListNode*pre=malloc(sizeof(struct ListNode));
    pre->val=0;
    pre->next=head;
    struct ListNode*cur=pre;
    while(cur->next){
        if(cur->next->val==val){
            struct ListNode*temp=cur->next;
            cur->next=temp->next;
            free(temp);
        }
        else cur=cur->next;
    }
    head=pre->next;//ï¼Ÿï¼Ÿï¼Ÿæœ‰ä»€ä¹ˆç”¨ï¼Ÿï¼Ÿ
    free(pre);
    return head;
}
```





### 3.é“¾è¡¨ç›¸äº¤(ç®€å•)



ç»™ä½ ä¸¤ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `headA` å’Œ `headB` ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤ç‚¹ï¼Œè¿”å› `null` ã€‚





```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode*a=headA;
    struct ListNode*b=headB;
    while(a!=b){
        a = (a==NULL?headB:a->next);
        b = (b==NULL?headA:b->next);
    }
    return a;
}
```



### 4.ç¯å½¢é“¾è¡¨â…¡(ä¸­ç­‰)

142





è¿™ä¸ªé¢˜æ„Ÿè§‰ç”¨åˆ°äº†æ•°å­¦å½’çº³æ³•

ç»™å®šä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹  head ï¼Œè¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å› nullã€‚

å¦‚æœé“¾è¡¨ä¸­æœ‰æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡è¿ç»­è·Ÿè¸ª next æŒ‡é’ˆå†æ¬¡åˆ°è¾¾ï¼Œåˆ™é“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œè¯„æµ‹ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨æ•´æ•° pos æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚å¦‚æœ pos æ˜¯ -1ï¼Œåˆ™åœ¨è¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚æ³¨æ„ï¼špos ä¸ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’ï¼Œä»…ä»…æ˜¯ä¸ºäº†æ ‡è¯†é“¾è¡¨çš„å®é™…æƒ…å†µã€‚

ä¸å…è®¸ä¿®æ”¹ é“¾è¡¨ã€‚



```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 /*éš¾ç‚¹ï¼šå¦‚ä½•æ‰¾åˆ°ç¯çš„å…¥å£
    æ‰¾åˆ°ç›¸é‡èŠ‚ç‚¹æ—¶ï¼Œè®©æ…¢æŒ‡é’ˆå›åˆ°å¤´èŠ‚ç‚¹ï¼Œéƒ½ä¸€æ¬¡èµ°ä¸€æ­¥ï¼Œç›¸é‡å³ä¸ºèŠ‚ç‚¹
 */
struct ListNode *detectCycle(struct ListNode *head) {
    if(!head)return NULL;

    //å¿«æ…¢æŒ‡é’ˆ
    struct ListNode*low=head,*fast=head;
    while(fast&&fast->next){
        fast=fast->next->next;
        low=low->next;
        //æ‰¾å…¥å£
        if(fast==low){
            low=head;
            while(fast!=low){
                fast=fast->next;
                low=low->next;
            }
            return fast;
        }
    }
    return NULL;
}
```





### 5.ç”¨æ ˆ(é“¾è¡¨)å®ç°é˜Ÿåˆ—(simple)



```
/*
    é“¾è¡¨å®ç°
*/
typedef struct Queue{
    int val;
    struct Queue *next;
} MyQueue;

//åˆ›å»ºé˜Ÿåˆ—
MyQueue* myQueueCreate() {
    MyQueue *L=(MyQueue*)malloc(sizeof(struct Queue));
    L->next=NULL;
    L->val=0;
    return L;
}
//å‹å…¥å…ƒç´ 
void myQueuePush(MyQueue* obj, int x) {
    //é“¾è¡¨åˆ›å»ºæ–°ç»“ç‚¹ï¼Œå¤´æ’æ³•
    struct Queue *t=obj->next;
    struct Queue *a=(MyQueue*)malloc(sizeof(struct Queue));
    a->val=x;
    a->next=t;
    obj->next=a;
}
//è¿”å›é˜Ÿå¤´å…ƒç´ 
int myQueuePop(MyQueue* obj) {//å…ˆè¿›å…ˆå‡ºï¼Œè¿”å›ç¬¬ä¸€ä¸ªè¿›çš„å³å¤´æ’æ³•ä¸­æœ€åä¸€ä¸ª
        struct Queue *t=obj->next,*pre=obj;
        while(t->next){
            pre=pre->next;
            t=t->next;
        }
        pre->next=NULL;
        int a=t->val;
        free(t);
        return a;
}
//å¼¹å‡ºé˜Ÿåˆ—å¤´å…ƒç´ 
int myQueuePeek(MyQueue* obj) {
        struct Queue *t=obj->next;
        while(t->next)t=t->next;
        return t->val; 
}
//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
bool myQueueEmpty(MyQueue* obj) {
    if(obj->next)return false;//å­˜åœ¨é˜Ÿåˆ—æ»¡
    return true;
}
//é‡Šæ”¾é˜Ÿåˆ—
void myQueueFree(MyQueue* obj) {
    while(obj){
        struct Queue *t=obj;
        obj=obj->next;
        free(t);
    }
}

/**
 * Your MyQueue struct will be instantiated and called as such:
 * MyQueue* obj = myQueueCreate();
 * myQueuePush(obj, x);
 
 * int param_2 = myQueuePop(obj);
 
 * int param_3 = myQueuePeek(obj);
 
 * bool param_4 = myQueueEmpty(obj);
 
 * myQueueFree(obj);
*/
```





### 6.å°†ä¸¤ä¸ªé“¾è¡¨åˆå¹¶æˆä¸€ä¸ªé“¾è¡¨(PTA) (Bugæ»¡å¤©é£ğŸ˜…)ä¸ºä»€ä¹ˆPTAèƒ½è¿‡ï¼Œç¼–è¯‘å™¨è¿‡ä¸äº†ï¼Ÿï¼Ÿ



è¾“å…¥ä¸¤è¡Œï¼Œåˆ†åˆ«åœ¨æ¯è¡Œç»™å‡ºç”±è‹¥å¹²ä¸ªæ­£æ•´æ•°æ„æˆçš„éé™åºåºåˆ—ï¼Œç”¨âˆ’1è¡¨ç¤ºåºåˆ—çš„ç»“å°¾ï¼ˆâˆ’1ä¸å±äºè¿™ä¸ªåºåˆ—ï¼‰ã€‚æ•°å­—ç”¨ç©ºæ ¼é—´éš”ã€‚

åœ¨ä¸€è¡Œä¸­è¾“å‡ºåˆå¹¶åæ–°çš„éé™åºé“¾è¡¨ï¼Œæ•°å­—é—´ç”¨ç©ºæ ¼åˆ†å¼€ï¼Œç»“å°¾ä¸èƒ½æœ‰å¤šä½™ç©ºæ ¼ï¼›è‹¥æ–°é“¾è¡¨ä¸ºç©ºï¼Œè¾“å‡º`NULL`ã€‚

```in
1 3 5 -1
2 4 6 8 10 -1
```

```out
1 2 3 4 5 6 8 10
```





```
#include<stdio.h>
#include<stdlib.h>
typedef struct List{
    int val;
    struct List *next;
}*LNode;
//åˆ›é€ é“¾è¡¨
struct List* creative(void){
    LNode L=(LNode)malloc(sizeof(struct List));
    LNode t=L;
    L->next=NULL;
    L->val=0;
    int e;
    scanf("%d",&e);
    while(e!=-1){
        LNode temp=(LNode)malloc(sizeof(struct List));
        temp->next=NULL;
        temp->val=e;
        t->next=temp;
        t=temp;
        scanf("%d",&e);
    }
    return L->next;
}
//æ’å…¥
void insert(LNode L,int e){
	LNode t=L;
	while(t->next){
		t=t->next;
	} 
	LNode temp=(LNode)malloc(sizeof(struct List));
	temp->val=e;
	temp->next=NULL;
	t->next=temp;
} 
//æ‰“å°
void print(LNode L){
	LNode t=L->next;
    if(!t){
        printf("NULL");
        return ;
    }
	while(t){
        if(t->next)
		printf("%d ",t->val);
        else
            printf("%d",t->val);
		t=t->next;
	}
    printf("\n");
} 
int main()
{
    LNode L1,L2;
    L1=creative();
    L2=creative();
    LNode new=(LNode)malloc(sizeof(struct List));
    while(L1&&L2){
    	if(L1->val<L2->val){
    		insert(new,L1->val);
    		L1=L1->next;
		}
		else{
			insert(new,L2->val);
			L2=L2->next;
		}
	}
	LNode t=new;
	while(t->next)t=t->next;
	if(L2)t->next=L2;
	if(L1)t->next=L1; 
	print(new);
    return 0;
}
```





### 7.åˆ é™¤é“¾è¡¨ä¸­çš„ç»“ç‚¹(ç®€å•)

åªç»™ä¸€ä¸ªç»“ç‚¹ï¼Œåˆ é™¤è¿™ä¸ªç»“ç‚¹

```
void deleteNode(struct ListNode* node) {
    struct ListNode *t=node->next;
    while(t->next){
        node->val=t->val;
        node=node->next;
        t=t->next;
    }
    node->val=t->val;
    node->next=NULL;
}
```











**importantï¼šwhileå¾ªç¯å†…æ¡ä»¶ï¼Œæœ‰å…ˆåå¾ªåºï¼Œè®©å°çš„åœ¨å‰ï¼Œåˆ¤æ–­å®Œç›´æ¥è¿”å›ï¼Œé˜²æ­¢å‡ºç°ç©ºæŒ‡é’ˆ**









# æ ‘

### 1.äºŒå‰æ ‘çš„ä¸­åºéå†(ç®€å•)

é€’å½’å®ç°(âˆš)

è¿­ä»£å®ç°

morriså®ç°

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 
void inordertree(struct TreeNode *root,int *res, int *reSize)
 {
     if(root==NULL)return;
     inordertree(root->left,res,reSize);
     res[(*reSize)++] = root->val;
     inordertree(root->right,res,reSize);
 }
int* inorderTraversal(struct TreeNode* root, int* returnSize){
    *returnSize=0;
    int *res=malloc(sizeof(int*)*500);
    inordertree(root,res,returnSize);
    return res;

}
```



### 2.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦(ç®€å•)



ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦ã€‚

äºŒå‰æ ‘çš„æ·±åº¦ä¸ºæ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚

**è¯´æ˜:** å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚





```
int maxDepth(struct TreeNode* root){
    if(root){
        int l=maxDepth(root->left)+1;
        int r=maxDepth(root->right)+1;
        int max=l>r?l:r;
        return max;
    }
    return 0;
}
```



### 3.äºŒå‰æ ‘çš„å±‚åºéå†



102



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    *returnColumnSizes=(int*)malloc(sizeof(int)*2000);
    int **result=(int**)malloc(sizeof(int*)*2000);
    *returnSize=0;
    if(!root)return result;
    //å¼€è¾ŸæŒ‡é’ˆç»“æ„ä½“æ•°ç»„
    struct TreeNode *queue[2000];
    //å…ˆå°†æ ¹èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—
    int l=0,r=0;
    queue[r++]=root;
    while(l<r){
        int cnt=0;//è®°å½•æ¯å±‚çš„æ•°
        int temp=r;//è®°å½•å½“å‰å±‚æ•°ç”±å¤šå°‘ä¸ªæ•°
        result[*returnSize]=(int*)malloc(sizeof(int)*1000);
        while(l<temp){
            if(queue[l]->left)queue[r++]=queue[l]->left;
            if(queue[l]->right)queue[r++]=queue[l]->right;
            result[*returnSize][cnt++]=queue[l++]->val;
        }
        (*returnColumnSizes)[(*returnSize)++]=cnt;
    }
    return result;
}
```

### 4.äºŒå‰æ ‘çš„å±‚åºéå†â…¡



107



ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼ **è‡ªåº•å‘ä¸Šçš„å±‚åºéå†** ã€‚ ï¼ˆå³æŒ‰ä»å¶å­èŠ‚ç‚¹æ‰€åœ¨å±‚åˆ°æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å±‚ï¼Œé€å±‚ä»å·¦å‘å³éå†ï¼‰

 



å¯¹å±‚åºéå†æ•°ç»„è¿›è¡Œåè½¬

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
 //å±‚åºéå†åŠ åè½¬
 #define max 2001
int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    int **result=(int**)malloc(sizeof(int*)*max);
    *returnColumnSizes=(int*)malloc(sizeof(int)*max);
    *returnSize=0;
    if(!root)return result;
    struct TreeNode *queue[max];
    int l=0,r=0;
    queue[r++]=root;
    while(l<r){
        int cnt=0;
        int temp=r;
        result[*returnSize]=(int*)malloc(sizeof(int)*max);
        while(l<temp){
            if(queue[l]->left)queue[r++]=queue[l]->left;
            if(queue[l]->right)queue[r++]=queue[l]->right;
            result[(*returnSize)][cnt++]=queue[l++]->val;
        }
        (*returnColumnSizes)[(*returnSize)++]=cnt;
    }
    struct TreeNode *a;
    int b;
    for(int i=0,j=(*returnSize)-1;i<j;++i,--j){
        a=result[i];
        result[i]=result[j];
        result[j]=a;
        b=(*returnColumnSizes)[i];
        (*returnColumnSizes)[i]=(*returnColumnSizes)[j];
        (*returnColumnSizes)[j]=b;
    }
    return result;
}
```

### 5.äºŒå‰æ ‘çš„å³è§†å›¾



199



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 //å±‚åºéå†ï¼Œæ¯æ¬¡éƒ½è®°å½•æœ€åä¸€ä¸ªæ•°
int* rightSideView(struct TreeNode* root, int* returnSize){
    //å»ºç«‹é˜Ÿåˆ—
    struct TreeNode *q[10000];
    //è¿”å›æ•°ç»„
    int *result=(int*)malloc(sizeof(int)*100);

    *returnSize=0;
    if(!root)return result;
    int l=0,r=0;
    q[r++]=root;
    result[(*returnSize)]=root->val;
    while(l<r){
        int temp=r;
        while(l<temp){
            if(q[l]->left)q[r++]=q[l]->left;
            if(q[l]->right)q[r++]=q[l]->right;
            l++;
        }
        //for(int i=l;i<r;++i)printf("%d ",q[i]->val);
        result[++(*returnSize)]=q[r-1]->val;
    }
    return result;
}
```



### 6.äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼(ç®€å•)

637



ç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` , ä»¥æ•°ç»„çš„å½¢å¼è¿”å›æ¯ä¸€å±‚èŠ‚ç‚¹çš„å¹³å‡å€¼ã€‚ä¸å®é™…ç­”æ¡ˆç›¸å·® `10-5` ä»¥å†…çš„ç­”æ¡ˆå¯ä»¥è¢«æ¥å—ã€‚



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
double* averageOfLevels(struct TreeNode* root, int* returnSize){
    struct TreeNode*q[10000];
    *returnSize=0;
    double *result=(double*)malloc(sizeof(double)*1001);
    int l=0,r=0;
    q[r++]=root;
    while(l<r){
        double sum=0;
        int cnt=0;
        int temp=r;
        while(l<temp){
            sum+=q[l]->val;
            cnt++;
            if(q[l]->left)q[r++]=q[l]->left;
            if(q[l]->right)q[r++]=q[l]->right;
            l++;
        }
        result[(*returnSize)++]=sum/cnt;
    }
    return result;
}
```

### 7. Nå‰æ ‘çš„å±‚åºéå†

429



```
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     int numChildren;
 *     struct Node** children;
 * };
 */

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
 
int** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes) {
    *returnSize=0;
    *returnColumnSizes=(int**)malloc(sizeof(int*)*1000);
    int **result=(int**)malloc(sizeof(int*)*1000);
    if(!root)return result;
    
    struct Node*q[10000];
    int l=0,r=0;
    q[r++]=root;
    while(l<r){
        int temp=r;
        int ColSize=0;//è®°å½•æ¯å±‚ç”±å¤šå°‘æ•°
        result[*returnSize]=(int*)malloc(sizeof(int)*(r-l+1));

        while(l<temp){ 
            result[(*returnSize)][ColSize++]=q[l]->val;//è®°å½•å½“å‰æ•°çš„å€¼
            if(q[l]->numChildren){   
                for(int i=0;i<q[l]->numChildren;++i)q[r++]=q[l]->children[i];
            }
            l++;
        }

        (*returnColumnSizes)[(*returnSize)++]=ColSize;
    }
    return result;
}
```



### 8.åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼

515

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* largestValues(struct TreeNode* root, int* returnSize){
    int *result=(int*)malloc(sizeof(int)*10000);
    *returnSize=0;
    if(!root)return result;
    struct TreeNode*q[10000];
    int l=0,r=0;
    q[r++]=root;
    while(l<r){
        int temp=r;
        int max=q[l]->val;
        while(l<temp){
            if(q[l]->val>max)max=q[l]->val;
            if(q[l]->left)q[r++]=q[l]->left;
            if(q[l]->right)q[r++]=q[l]->right;
            l++;
        }
        result[(*returnSize)++]=max;
    }
    return result;
}
```



### 9.å¡«å……æ¯ä¸€ä¸ªç»“ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§æŒ‡é’ˆ



116

```
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     struct Node *left;
 *     struct Node *right;
 *     struct Node *next;
 * };
 */

struct Node* connect(struct Node* root) {
	if(!root)return root;
    struct Node *q[10000];
    int l=0,r=0;
    q[r++]=root;
    while(l<r){
        int tem=l;
        int temp=r;
        while(l<temp){
            if(q[l]->left)q[r++]=q[l]->left;
            if(q[l]->right)q[r++]=q[l]->right;
            l++;
        }
        for(int i=tem;i<(temp-1);++i)q[i]->next=q[i+1];
    }
    return root;
}
```



other

ä¸å¼€è¾Ÿæ–°ç©ºé—´

ç©ºé—´å¤æ‚åº¦ O(1)

```
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     struct Node *left;
 *     struct Node *right;
 *     struct Node *next;
 * };
 */
//æ¯æ¬¡ä¾æ®ä¸Šå±‚çš„nextä½ç½®å·²ç»çŸ¥é“
struct Node* connect(struct Node* root) {
	if(!root)return root;
    struct Node*pre=root;
    while(pre->left){
        struct Node *temp=pre;
        while(temp){
            temp->left->next=temp->right;//è¿æ¥çˆ¶æ¯èŠ‚ç‚¹ä¸‹çš„å·¦å³
            if(temp->next)temp->right->next=temp->next->left;//è¿æ¥äº²æˆšé—´çš„ç»“ç‚¹
            temp=temp->next;
        }
        pre=pre->left;
    }
    return root;
}
```



### 10.ç¿»è½¬äºŒå‰æ ‘



226



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

struct TreeNode* invertTree(struct TreeNode* root){
    if(root==NULL)return NULL;
    //å°†å·¦å³ç»“ç‚¹äº¤æ¢
    struct TreeNode *t=root->left;
    root->left=root->right;
    root->right=t;
    //ç»§ç»­äº¤æ¢åç»­ç»“ç‚¹
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```



### 11.å¯¹ç§°äºŒå‰æ ‘



111



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
bool compare(struct TreeNode *left,struct TreeNode *right){
    //éƒ½ä¸ºç©º
    if(left==NULL&&right==NULL)
        return true;
    //æœ‰ä¸€ä¸ªä¸ºç©º
    if(left==NULL||right==NULL)
        return false;
    //å€¼ä¸ç›¸ç­‰
    if(left->val!=right->val)
        return false;
    //å€¼éƒ½å­˜åœ¨è¿›è¡Œæ¯”è¾ƒ
    return compare(left->left,right->right)&&compare(left->right,right->left);
}

bool isSymmetric(struct TreeNode* root){
    if(!root)return true;
    return compare(root->left,root->right);
}

```



### 12.å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°



222



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
//å±‚åºéå†

int countNodes(struct TreeNode* root){
    if(!root)return 0;
    struct TreeNode*q[60000];
    int l=0,r=0;
    int cnt=1;
    q[r++]=root;
    while(l<r){
        int temp=r;
        while(l<temp){
            if(q[l]->left)
            {
                q[r++]=q[l]->left;
                cnt++;
            }
            if(q[l]->right)
            {
                q[r++]=q[l]->right;
                cnt++;
            }
            l++;
        }
    }
    return cnt;
}
```



```
//é€’å½’dfs

int countNodes(struct TreeNode* root){
    if(!root)return 0;
    else return countNodes(root->left)+countNodes(root->right)+1;
}
```

### 13.å¹³è¡¡äºŒå‰æ ‘

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
 //æ±‚å·¦å³æ ‘é«˜åº¦ï¼Œå¦‚æœå¤§äº 1 å°±è¿”å› -1
int dfs(struct TreeNode *root)
{
    if(!root)return 0;
    int l=dfs(root->left);
    if(l==-1)return -1;
    int r=dfs(root->right);
    if(r==-1)return -1;
    if(abs(l-r)>1)return -1;
    else return fmax(l,r)+1;
}

bool isBalanced(struct TreeNode* root){
    return dfs(root)!=-1;
}
```



### 14.äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„(å›æº¯)





```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

char ** binaryTreePaths(struct TreeNode* root, int* returnSize){
    
    char **result=(char**)malloc(sizeof(char*)*1000);
    *returnSize=0;
    int ans[1024];//å­˜æ”¾æ•°
    paths(root,result,returnSize,ans,0);
    return result;
}
void paths(struct TreeNode *root,char**result,int *returnSize,int *ans,int local){
    if(!root)return ;
    if(!root->left&&!root->right){
        int len=0;
        char *t=(char*)malloc(sizeof(char)*1001);
        for(int i=0;i<local;++i){
            len+=sprintf(len+t,"%d->",ans[i]);
        }
        sprintf(t+len,"%d",root->val);
        result[(*returnSize)++]=t;
    }
    else {
        ans[local++]=root->val;
        if(root->left)paths(root->left,result,returnSize,ans,local);
        if(root->right)paths(root->right,result,returnSize,ans,local);
    }
}
```



### 15.æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼





å±‚åºéå†ï¼Œæ¯æ¬¡éƒ½è®°å½•ç¬¬ä¸€ä¸ªå€¼å³ä¸ºæœ€å·¦è¾¹çš„å€¼

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

//å±‚åºéå†
int findBottomLeftValue(struct TreeNode* root){
    struct TreeNode*q[10001];
    int l=0,r=0;
    q[r++]=root;
    int ans=0;
    while(l<r){
        int temp=r;
        ans=q[l]->val;
        while(l<temp){
            if(q[l]->left)q[r++]=q[l]->left;
            if(q[l]->right)q[r++]=q[l]->right;
            l++;
        }
    }
    return ans;
}
```



### 16.è·¯å¾„æ€»å’Œ



æ‰¾ä¸€æ¡è·¯å¾„ä¸Šçš„æ€»å’Œç­‰äºç»™å®šçš„æ•°







```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

//å›æº¯é—®é¢˜
bool tb(struct TreeNode*root,int count){
    //ç»ˆæ­¢æ¡ä»¶
    if(!root->left&&!root->right&&count==0)return true;
    else {
        if(root->left){
            if(tb(root->left,count-root->left->val))return true;
        }
        if(root->right){
            if(tb(root->right,count-root->right->val))return true;
        }
    }
    return false;
}
bool hasPathSum(struct TreeNode* root, int targetSum){
    if(!root)return false;
    int count=targetSum;
    return tb(root,count-root->val);
}
```



### 17.ä¸­åºéå†å’Œååºéå†æ„é€ äºŒå‰æ ‘



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

/*
    é€’å½’åˆ‡å‰²ä¸­åºæ•°ç»„å’Œååºæ•°ç»„
    éš¾ç‚¹åœ¨äºå¦‚ä½•åˆ‡å‰²ï¼Œè¾¹ç•Œé—®é¢˜
*/
struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){
    //å¦‚æœæ ¹èŠ‚ç‚¹ä¸ºç©ºæˆ–è€…ä¸ºå¶å­èŠ‚ç‚¹
    if(inorder==0||postorderSize==0)return NULL;
    //ååºéå†æœ€åä¸€ä¸ªä¸ºäº²èŠ‚ç‚¹
    struct TreeNode *root=(struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val=postorder[postorderSize-1];
    //ä»å‰åºéå†ä¸­æ‰¾åˆ°äº²èŠ‚ç‚¹çš„å€¼ï¼Œè¿›è¡Œåˆ†å‰²
    int left;
    for(left=0;left<inorderSize;++left)if(inorder[left]==root->val)break;
    
    int right=postorderSize-left-1;//å³å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œleftä¸ºå·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°

    root->left=buildTree(inorder,left,postorder,left);
    root->right=buildTree(inorder+left+1,right,postorder+left,right);
    return root;
}
```



### 18.å‰åºå’Œä¸­åºæ„é€ äºŒå‰æ ‘



![image-20220419161401602](C:\Users\boy\AppData\Roaming\Typora\typora-user-images\image-20220419161401602.png)





```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize){
    if(preorderSize==0||inorderSize==0)return NULL;
    struct TreeNode*root=(struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val=preorder[0];
    int left;
    for(left=0;left<inorderSize;++left)if(inorder[left]==root->val)break;
    int right=inorderSize-left-1;
    root->left=buildTree(preorder+1,left,inorder,left);
    root->right=buildTree(preorder+left+1,right,inorder+left+1,right);
    return root;
}
```



### 19.æœ€å¤§äºŒå‰æ ‘

ç»™å®šä¸€ä¸ªä¸é‡å¤çš„æ•´æ•°æ•°ç»„ nums ã€‚ æœ€å¤§äºŒå‰æ ‘ å¯ä»¥ç”¨ä¸‹é¢çš„ç®—æ³•ä» nums é€’å½’åœ°æ„å»º:

åˆ›å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º nums ä¸­çš„æœ€å¤§å€¼ã€‚
é€’å½’åœ°åœ¨æœ€å¤§å€¼ å·¦è¾¹ çš„ å­æ•°ç»„å‰ç¼€ä¸Š æ„å»ºå·¦å­æ ‘ã€‚
é€’å½’åœ°åœ¨æœ€å¤§å€¼ å³è¾¹ çš„ å­æ•°ç»„åç¼€ä¸Š æ„å»ºå³å­æ ‘ã€‚
è¿”å› nums æ„å»ºçš„ æœ€å¤§äºŒå‰æ ‘ ã€‚

 

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/maximum-binary-tree







```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize){
    if(numsSize==0)return NULL;
    int maxi=0,max=0;
    for(int i=0;i<numsSize;++i)if(nums[i]>max){max=nums[i];maxi=i;}
    struct TreeNode *root=(struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val=max;
    root->left=constructMaximumBinaryTree(nums,maxi);
    root->right=constructMaximumBinaryTree(nums+maxi+1,numsSize-maxi-1);
    return root;
}
```



### 20.åˆå¹¶ä¸¤ä¸ªäºŒå‰æ ‘



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

//ç›´æ¥åœ¨åŸæ ‘ä¸Šè¿›è¡Œä¿®æ”¹
struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){
    if(!root1)return root2;
    if(!root2)return root1;
    root1->val+=root2->val;
    root1->left=mergeTrees(root1->left,root2->left);
    root1->right=mergeTrees(root1->right,root2->right);
    return root1;
}
```





### 21.äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢





è¿­ä»£

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* searchBST(struct TreeNode* root, int val){
    while(root){
        if(root->val>val)root=root->left;
        else if(root->val<val) root=root->right;
        else return root;
    }
    return NULL;
}
```



é€’å½’



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* searchBST(struct TreeNode* root, int val){
    if(root==NULL||root->val==val)return root;
    else if(root->val>val)return searchBST(root->left,val);
    else if(root->val<val)return searchBST(root->right,val);
    return NULL;
}
```



### 22.éªŒè¯äºŒå‰æœç´¢æ ‘ï¼ˆboomï¼‰



```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
void traver(struct TreeNode*root,int *a,int *i){
    if(root){
        traver(root->left,a,i);//æ­¤æ—¶ i å·²ç»æ˜¯æŒ‡é’ˆï¼Œä¼ å…¥çš„æ—¶å€™ç›´æ¥ä¼  i å°±å¥½
        a[(*i)++]=root->val;
        traver(root->right,a,i);
    }
}
bool isValidBST(struct TreeNode* root){
    int a[10001];
    int i=0;
    traver(root,a,&i);
    //for(int j=0;j<i;++j)printf("%d ",a[j]);
    for(int j=0;j<i-1;++j)if(a[j]>=a[j+1])return false;
    return true;
}
```



### 23.äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®





```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
void traverse(struct TreeNode*root,int *a,int *i){
    if(!root)return ;
    traverse(root->left,a,i);
    a[(*i)++]=root->val;
    traverse(root->right,a,i);
}

int getMinimumDifference(struct TreeNode* root){
    if(!root)return ;
    int a[10001];
    int i=0;
    traverse(root,a,&i);
    int min=INT_MAX;
    for(int j=1;j<i;++j){
        if(abs(a[j]-a[j-1])<min)min=abs(a[j]-a[j-1]);
    }
    return min;
}
```



### 24.äºŒå‰æœç´¢æ ‘çš„ä¼—æ•°





```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    int count=0,maxcount=0;
    struct TreeNode*pre=NULL;
    vector<int>result;
    void traverse(struct TreeNode*root){
        if(!root)return ;
        traverse(root->left);//å·¦

        //å¯¹æ•°æ®çš„å¤„ç†
        //åˆ¤æ–­ä¸å‰ä¸€ä¸ªæ•°çš„å…³ç³»
        if(pre==NULL)count=1;
        else if(pre->val==root->val)count++;
        else count=1;
        pre=root;

        //åˆ¤æ–­è¯¥æ•°å‡ºç°çš„æ¬¡æ•°
        if(maxcount==count){
            result.push_back(root->val);
        }
        else if(maxcount<count){
            maxcount=count;
            result.clear();
            result.push_back(root->val);
        }

        traverse(root->right);//å³
    }
public:
    vector<int> findMode(TreeNode* root) {
        traverse(root);
        return result;
    }
};
```







### 25.äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ



ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€

 

ç¤ºä¾‹ 1ï¼š

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
è¾“å‡ºï¼š3
è§£é‡Šï¼šèŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 1 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 3 ã€‚
ç¤ºä¾‹ 2ï¼š


è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
è¾“å‡ºï¼š5
è§£é‡Šï¼šèŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 4 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 5 ã€‚å› ä¸ºæ ¹æ®å®šä¹‰æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹å¯ä»¥ä¸ºèŠ‚ç‚¹æœ¬èº«ã€‚
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šroot = [1,2], p = 1, q = 2
è¾“å‡ºï¼š1

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚





```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 /*
    1.å¦‚æœè¯¥èŠ‚ç‚¹ç­‰äºp æˆ–q æˆ–è€…ä¸ºç©º ç›´æ¥è¿”å›
    2.å¦‚æœå·¦å³èŠ‚ç‚¹éƒ½å­˜åœ¨è¿”å›ç¥–å…ˆèŠ‚ç‚¹
    3.é€’å½’å·¦å³èŠ‚ç‚¹ï¼Œè¿”å›å­˜åœ¨çš„é‚£ä¸ªèŠ‚ç‚¹
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root||p==root||q==root)return root;
        TreeNode *left=lowestCommonAncestor(root->left,p,q);
        TreeNode *right=lowestCommonAncestor(root->right,p,q);
        if(left&&right)return root;
        return left==NULL?right:left;
    }
};
```



### 26.äºŒå‰æœç´¢æ ‘çš„æ’å…¥



```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(!root){
            TreeNode*t=new TreeNode(val);
            return t;
        }
        if(root->val<val)root->right = insertIntoBST(root->right,val);
        if(root->val>val)root->left=insertIntoBST(root->left,val);
        return root;
    }
};
```



### 27.äºŒå‰æœç´¢æ ‘çš„åˆ é™¤



```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 /*
    äº”ç§æƒ…å†µ
    1.æ ¹èŠ‚ç‚¹ä¸å­˜åœ¨
    2.åˆ é™¤èŠ‚ç‚¹çš„å·¦å³å­©å­ä¸ºç©º ç›´æ¥åˆ é™¤
    3.åˆ é™¤å­©å­çš„å·¦èŠ‚ç‚¹ä¸ºç©ºï¼Œå³èŠ‚ç‚¹è¡¥ä½
    4.åˆ é™¤å­©å­çš„å³èŠ‚ç‚¹ä¸ºç©ºï¼Œå·¦èŠ‚ç‚¹è¡¥ä½
    5ã€‚å·¦å³èŠ‚ç‚¹éƒ½å­˜åœ¨ï¼Œå°†å·¦èŠ‚ç‚¹æ”¾åˆ°å³èŠ‚ç‚¹çš„æœ€å·¦è¾¹
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root)return root;
        if(root->val==key){
            if(!root->left&&!root->right)
            {
                delete root;
                return NULL;
            }
            else if(!root->left&&root->right)return root->right;
            else if(root->left&&!root->right)return root->left;
            else 
            {
                TreeNode*cur=root->right;
                TreeNode*t=root->right;
                while(t->left)t=t->left;
                t->left=root->left;
                delete root;
                return cur;
            }
        }
        if(root->val>key)root->left=deleteNode(root->left,key);
        if(root->val<key)root->right=deleteNode(root->right,key);
        return root;
    }
};

```



### 28.æ ‘çš„å­ç»“æ„

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 /*
    å…ˆå¯¹æ ¹èŠ‚ç‚¹è¿›è¡Œåˆ¤æ–­
    ç„¶åå°†Açš„å­æ ‘ä¸Bè¿›è¡Œåˆ¤æ–­
    åˆ¤æ–­å‡½æ•° Bç©ºtrue
            å€¼ä¸ç›¸ç­‰false
            åœ¨è¿›è¡Œå·¦å³å­æ ‘åˆ¤æ–­
 */
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        return (A!=NULL&&B!=NULL)&&(boolis(A,B)||isSubStructure(A->left,B)||isSubStructure(A->right,B));
    }
    bool boolis(struct TreeNode *A,struct TreeNode *B){
        if(B==NULL)return true;
        if(A==NULL||A->val!=B->val)return false;
        return boolis(A->left,B->left)&&boolis(A->right,B->right);
    }
};
```



```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSubStructure(A *TreeNode, B *TreeNode) bool {
    return (A!=nil && B!=nil)&&(boolis(A,B)||isSubStructure(A.Left,B)||isSubStructure(A.Right,B))
}
func boolis (A *TreeNode , B *TreeNode) bool {
    if B == nil {
        return true
    }
    if A == nil || A.Val!=B.Val {
        return false
    }
    return boolis(A.Left,B.Left) && boolis(A.Right,B.Right)
}
```



### 29.äºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 /*
    é¡ºåºï¼šå³ ä¸­ å·¦
 */
class Solution {
    private:
    int pre=0;
    void sumbin(TreeNode *root){
        if(!root)return ;
        sumbin(root->right);
        pre+=root->val;
        root->val=pre;
        sumbin(root->left);
    }
public:
    TreeNode* convertBST(TreeNode* root) {
        sumbin(root);
        return root;
    }
};
```





# å›æº¯

### 1.å…¨æ’åˆ—

ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ nums ï¼Œè¿”å›å…¶ æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ— ã€‚ä½ å¯ä»¥ æŒ‰ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚

 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šnums = [1,2,3]
è¾“å‡ºï¼š[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/permutations
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚







```
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> re;
        vector<int> use(nums.size(),0);
        def(res,re,use,nums);
        return res;
    }
    void def(vector<vector<int>>&res,vector<int>&re,vector<int>&use,vector<int> &nums){
        if(re.size()==nums.size()){
            res.push_back(re);
            return ;
        }
        else {
            for(int i=0;i<nums.size();++i){
                if(use[i]==0){
                    re.push_back(nums[i]);
                    use[i]=1;
                    def(res,re,use,nums);
                    use[i]=0;
                    re.pop_back();
                }
            }
        }
    }
};
```



### 2.ç»„åˆ

ç»™å®šä¸¤ä¸ªæ•´æ•° n å’Œ kï¼Œè¿”å›èŒƒå›´ [1, n] ä¸­æ‰€æœ‰å¯èƒ½çš„ k ä¸ªæ•°çš„ç»„åˆã€‚

ä½ å¯ä»¥æŒ‰ ä»»ä½•é¡ºåº è¿”å›ç­”æ¡ˆã€‚

 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šn = 4, k = 2
è¾“å‡ºï¼š
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/combinations
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚



```c++
class Solution {
    private:
    vector<vector<int> >result;
    vector<int> path;
    void backtracking(int n,int k,int startindex){
        if(path.size()==k){
            result.push_back(path);
        }
        else {
            for(int i=startindex;i<=n;++i){
                path.push_back(i);
                backtracking(n,k,i+1);
                path.pop_back();
            }
        }
        return;
    }
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }
};
```

å‰ªæ

![image-20220517223525070](C:\Users\boy\AppData\Roaming\Typora\typora-user-images\image-20220517223525070.png)





![image-20220517223550056](C:\Users\boy\AppData\Roaming\Typora\typora-user-images\image-20220517223550056.png)





```
class Solution {
    private:
    vector<vector<int> >result;
    vector<int> path;
    void backtracking(int n,int k,int startindex){
        if(path.size()==k){
            result.push_back(path);
        }
        else {
            for(int i=startindex;i<=n-(k-path.size())+1;++i){

                path.push_back(i);
                backtracking(n,k,i+1);
                path.pop_back();
            }
        }
        return;
    }
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }
};
```





### 3.ç»„åˆ





```
class Solution {
    private:
    vector<vector<int> >ans;
    vector<int>path;
    void comb(int k,int n,int sum,int idexs){
        if(sum>n)return ;
        if(path.size()==k&&sum==n){
            ans.push_back(path);
        }
        else {
            for(int i=idexs;i<=9;++i){
                sum+=i;
                path.push_back(i);
                comb(k,n,sum,i+1);
                path.pop_back();
                sum-=i;
            }
        }
    }
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        comb(k,n,0,1);
        return ans;
    }
};
```



### 4.ç”µè¯å·ç ç»„åˆ

ç»™å®šä¸€ä¸ªä»…åŒ…å«æ•°å­— 2-9 çš„å­—ç¬¦ä¸²ï¼Œè¿”å›æ‰€æœ‰å®ƒèƒ½è¡¨ç¤ºçš„å­—æ¯ç»„åˆã€‚ç­”æ¡ˆå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚

ç»™å‡ºæ•°å­—åˆ°å­—æ¯çš„æ˜ å°„å¦‚ä¸‹ï¼ˆä¸ç”µè¯æŒ‰é”®ç›¸åŒï¼‰ã€‚æ³¨æ„ 1 ä¸å¯¹åº”ä»»ä½•å­—æ¯ã€‚ã€‚

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)









```
class Solution {
    private:
    const string numbermap[10]{
        "",//0
        "",//1
        "abc",//2
        "def",//3
        "ghi",//4
        "jkl",//5
        "mno",//6
        "pqrs",//7
        "tuv",//8
        "wxyz",//9
    };
public:
    vector<string>result;
    string s;
    void bin(const string &digits,int idex){
        //ç»“æŸæ¡ä»¶
        if(digits.size()==idex){
            result.push_back(s);
            return ;
        }

        int digit=digits[idex]-'0';
        string letter=numbermap[digit];

        for(int i=0;i<letter.size();i++){
            s.push_back(letter[i]);

            bin(digits,idex+1);

            s.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.size()==0){
            return result;
        }
        bin(digits,0);
        return result;
    }
};
```

### 5.ç»„åˆæ€»æ•°



ç»™ä½ ä¸€ä¸ª æ— é‡å¤å…ƒç´  çš„æ•´æ•°æ•°ç»„ candidates å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° target ï¼Œæ‰¾å‡º candidates ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° target çš„ æ‰€æœ‰ ä¸åŒç»„åˆ ï¼Œå¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›è¿™äº›ç»„åˆã€‚

candidates ä¸­çš„ åŒä¸€ä¸ª æ•°å­—å¯ä»¥ æ— é™åˆ¶é‡å¤è¢«é€‰å– ã€‚å¦‚æœè‡³å°‘ä¸€ä¸ªæ•°å­—çš„è¢«é€‰æ•°é‡ä¸åŒï¼Œåˆ™ä¸¤ç§ç»„åˆæ˜¯ä¸åŒçš„ã€‚ 

å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œä¿è¯å’Œä¸º target çš„ä¸åŒç»„åˆæ•°å°‘äº 150 ä¸ªã€‚

 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šcandidates = [2,3,6,7], target = 7
è¾“å‡ºï¼š[[2,2,3],[7]]
è§£é‡Šï¼š
2 å’Œ 3 å¯ä»¥å½¢æˆä¸€ç»„å€™é€‰ï¼Œ2 + 2 + 3 = 7 ã€‚æ³¨æ„ 2 å¯ä»¥ä½¿ç”¨å¤šæ¬¡ã€‚
7 ä¹Ÿæ˜¯ä¸€ä¸ªå€™é€‰ï¼Œ 7 = 7 ã€‚
ä»…æœ‰è¿™ä¸¤ç§ç»„åˆã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/combination-sum



```
class Solution {
public:
    vector<vector<int> >result;
    vector<int>path;
    void tb(vector<int>&candidates,int target,int sum,int s){
        if(sum>target)return;
        if(sum==target){
            result.push_back(path);
            return;
        }
        for(int i=s;i<candidates.size();++i){
            path.push_back(candidates[i]);
            tb(candidates,target,sum+candidates[i],i);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        tb(candidates,target,0,0);
        return result;
    }
};
```

### 6.ç»„åˆæ€»æ•°



ç»™å®šä¸€ä¸ªå€™é€‰äººç¼–å·çš„é›†åˆ candidates å’Œä¸€ä¸ªç›®æ ‡æ•° target ï¼Œæ‰¾å‡º candidates ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º target çš„ç»„åˆã€‚

candidates ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ ä¸€æ¬¡ ã€‚

æ³¨æ„ï¼šè§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„ç»„åˆã€‚ 

 

ç¤ºä¾‹ 1:

è¾“å…¥: candidates = [10,1,2,7,6,1,5], target = 8,
è¾“å‡º:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/combination-sum-ii

```c++
class Solution {
private:
    vector<vector<int> > re;
    vector<int> path;
    void backtrack(vector<int>& candidates,int start,int target,int sum)
    {
        if(sum>target)return;
        if(sum==target)
        {
            re.push_back(path);
            return;
        }
        else
        {
            for(int i=start;i<candidates.size();++i)
            {
                if(i>start&&candidates[i]==candidates[i-1])continue;//ç²¾é«“
                path.push_back(candidates[i]);
                sum+=candidates[i];
                backtrack(candidates,i+1,target,sum);
                path.pop_back();
                sum-=candidates[i];
            }
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        backtrack(candidates,0,target,0);
        return re;
    }
};
```

### 7.æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    private:
    vector<int>s;
public:
    void dfs(TreeNode *root , int a)
    {
        if(!root)return ;
        if(s.size()==a)s.emplace_back(root->val);//ç¬¬ä¸€æ¬¡é‡è§ç›´æ¥æ”¾å…¥å®¹æ˜“
        else s[a]=s[a]>root->val?s[a]:root->val;//å†æ¬¡ç›¸åŒå±‚æ—¶ï¼Œè®°å½•æœ€å¤§å€¼
        if(root->left)dfs(root->left,a+1);
        if(root->right)dfs(root->right,a+1);
        
    }
    vector<int> largestValues(TreeNode* root) {
        dfs(root,0);
        return s;
    }
};
```



### 8.åˆ†å‰²å›æ–‡ä¸²



ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s`ï¼Œè¯·ä½ å°† `s` åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯ **å›æ–‡ä¸²** ã€‚è¿”å› `s` æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ¡ˆã€‚

**å›æ–‡ä¸²** æ˜¯æ­£ç€è¯»å’Œåç€è¯»éƒ½ä¸€æ ·çš„å­—ç¬¦ä¸²ã€‚

 

```c++
class Solution {
    private:
    vector<vector<string> >res;
    vector<string>path;
public:
    void trackblack(string &s,int start)
    {
        if(start>=s.size())
        {
            res.push_back(path);
            return ;
        }
        for(int i=start;i<s.size();++i)
        {
            if(islegal(s,start,i))//å¦‚æœæ˜¯å›æ–‡å­—ç¬¦ä¸²ï¼Œå°±æ”¾å…¥
            {
                string str=s.substr(start,i-start+1);
                path.push_back(str);
            }
            else 
            {
                continue;//å¦‚æœä¸æ˜¯å›æ–‡å­—ç¬¦ä¸²å°±å¾€åæ‰¾ ä¾‹å¦‚ abä¸æ˜¯ å¾€åæ‰¾aba
            }
            trackblack(s,i+1);//ç»§ç»­ä»é™¤äº†æ”¾å…¥å­—ç¬¦ä¸²ä¹‹å¤–çš„å­—ç¬¦ä¸²
            path.pop_back();//å›æº¯è¿‡ç¨‹
        }
    }
    bool islegal(string &s,int l,int r)//åˆ¤æ–­æ˜¯å¦ä¸ºä¼šé—®å­—ç¬¦ä¸²
    {
        while(l<r)
        {
            if(s[l]==s[r])
            {
                l++;
                r--;
            }
            else return false;
        }
        return true;
    }
    vector<vector<string>> partition(string s) {
        trackblack(s,0);
        return res;
    }
};
```



### 9.Nçš‡å



```
class Solution {
private:
    vector<vector<string> > result;
    
public:
    void backtrack(int n,int row,vector<string> &path)
    {
        if(row==n)
        {
            result.push_back(path);
            return ;
        }
        for(int col=0;col<n;col++)
        {
            if(IsEmpty(path,row,col,n))//å¦‚æœèƒ½å¤Ÿæ”¾ä¸‹çš‡åå°±ç»§ç»­å›æº¯ï¼Œä¸ç„¶å¯»æ‰¾ä¸‹ä¸€ä¸ªä½ç½®
            {
                path[row][col]='Q';
                backtrack(n,row+1,path);
                path[row][col]='.';
            }
        }
    }
    bool IsEmpty(vector<string> &path,int row,int col,int n)
    {
        for(int i=0;i<row;++i)//æ£€æŸ¥90
        {
            if(path[i][col]=='Q')return false;
        }
        for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--)//135
        {
            if(path[i][j]=='Q')return false;
        }
        for(int i=row-1,j=col+1;i>=0&&j<n;i--,j++)//45
        {
            if(path[i][j]=='Q')return false;
        }
        return true;
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string> path(n,string(n,'.'));
        backtrack(n,0,path);
        return result;
    }
};
```



### 10.å¤åŸIP

æœ‰æ•ˆ IP åœ°å€ æ­£å¥½ç”±å››ä¸ªæ•´æ•°ï¼ˆæ¯ä¸ªæ•´æ•°ä½äº 0 åˆ° 255 ä¹‹é—´ç»„æˆï¼Œä¸”ä¸èƒ½å«æœ‰å‰å¯¼ 0ï¼‰ï¼Œæ•´æ•°ä¹‹é—´ç”¨ '.' åˆ†éš”ã€‚

ä¾‹å¦‚ï¼š"0.1.2.201" å’Œ "192.168.1.1" æ˜¯ æœ‰æ•ˆ IP åœ°å€ï¼Œä½†æ˜¯ "0.011.255.245"ã€"192.168.1.312" å’Œ "192.168@1.1" æ˜¯ æ— æ•ˆ IP åœ°å€ã€‚
ç»™å®šä¸€ä¸ªåªåŒ…å«æ•°å­—çš„å­—ç¬¦ä¸² s ï¼Œç”¨ä»¥è¡¨ç¤ºä¸€ä¸ª IP åœ°å€ï¼Œè¿”å›æ‰€æœ‰å¯èƒ½çš„æœ‰æ•ˆ IP åœ°å€ï¼Œè¿™äº›åœ°å€å¯ä»¥é€šè¿‡åœ¨ s ä¸­æ’å…¥ '.' æ¥å½¢æˆã€‚ä½  ä¸èƒ½ é‡æ–°æ’åºæˆ–åˆ é™¤ s ä¸­çš„ä»»ä½•æ•°å­—ã€‚ä½ å¯ä»¥æŒ‰ ä»»ä½• é¡ºåºè¿”å›ç­”æ¡ˆã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/restore-ip-addresses






```
class Solution {
private:
    vector<string> result;
public:
    void backtrack(string &s,int start,int point)
    {
        if(point==3)//pointè®°å½•é€—å·æ•°é‡ï¼Œå¦‚æœæ˜¯3è¯æ˜åˆ†ä¸ºä¸‰æ®µ
        {
            if(isvalid(s,start,s.size()-1))//åˆ¤æ–­ç¬¬å››æ®µå­—ç¬¦æ˜¯å¦ç¬¦åˆ
            {
                result.push_back(s);
            }
            return;
        }
        for(int i=start;i<s.size();++i)
        {
            //å…ˆåˆ¤æ–­è¿™ä¸ªå­ä¸²æ˜¯å¦åˆæ³•ã€
            if(isvalid(s,start,i))
            {
                //åˆæ³•å°±å›æº¯
                s.insert(s.begin()+i+1,'.');//åœ¨içš„åé¢æ’å…¥ä»¥ä¸€ä¸ª.
                backtrack(s,i+2,point+1);
                s.erase(s.begin()+i+1);
            }
            else break;
        }
    }
    //åˆ¤æ–­å­—ç¬¦ä¸² [start ï¼Œ end]æ˜¯å¦åˆæ³•
    bool isvalid(string &s,int start,int end)
    {
        if(start>end)return false;
        if(s[start]=='0'&&start!=end)return false;//å‰å¯¼0
        int m=0;
        for(int i=start;i<=end;++i)
        {
            if(s[i]<'0'||s[i]>'9')return false;
            m=m*10+(s[i]-'0');
            if(m>255)return false;
        }
        return true;
    }
    vector<string> restoreIpAddresses(string s) {
        backtrack(s,0,0);
        return result;
    }
};
```









### 11.å­é›†â…¡



![image-20220708164002157](C:\Users\boy\AppData\Roaming\Typora\typora-user-images\image-20220708164002157.png)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å¯èƒ½åŒ…å«é‡å¤å…ƒç´ ï¼Œè¯·ä½ è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚

è§£é›† ä¸èƒ½ åŒ…å«é‡å¤çš„å­é›†ã€‚è¿”å›çš„è§£é›†ä¸­ï¼Œå­é›†å¯ä»¥æŒ‰ ä»»æ„é¡ºåº æ’åˆ—ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/subsets-ii

```c++
class Solution {
    vector<vector<int >> result;
    vector<int> path;
public:
    void backtrack(vector<int>&nums,int start ,vector<bool>&isvalid)
    {
        result.push_back(path);
        for(int i=start;i<nums.size();++i)
        {
            //isvalid[i-1]==trueè¯´æ˜nums[i-1]è¯¥æ ‘æå·²ç»ä½¿ç”¨è¿‡
            //isvalid[i-1]==falseè¯´æ˜nums[i-1]è¯¥å±‚å·²ç»ä½¿ç”¨è¿‡
            if(i>0&&nums[i]==nums[i-1]&&isvalid[i-1]==false)continue ;
            path.push_back(nums[i]);
            isvalid[i]=true;
            backtrack(nums,i+1,isvalid);
            isvalid[i]=false;
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<bool>isvalid(nums.size(),false);
        sort(nums.begin(),nums.end());
        backtrack(nums,0,isvalid);
        return result;
    }
};
```

### 12.é€’å¢å­åºåˆ—



ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾å‡ºå¹¶è¿”å›æ‰€æœ‰è¯¥æ•°ç»„ä¸­ä¸åŒçš„é€’å¢å­åºåˆ—ï¼Œé€’å¢å­åºåˆ—ä¸­ è‡³å°‘æœ‰ä¸¤ä¸ªå…ƒç´  ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚

æ•°ç»„ä¸­å¯èƒ½å«æœ‰é‡å¤å…ƒç´ ï¼Œå¦‚å‡ºç°ä¸¤ä¸ªæ•´æ•°ç›¸ç­‰ï¼Œä¹Ÿå¯ä»¥è§†ä½œé€’å¢åºåˆ—çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/increasing-subsequences





```c++
set å»é‡
set::find(elemt);
è¯¥åŠŸèƒ½æ£€æŸ¥å…ƒç´ æ˜¯å¦å±äºé›†åˆã€‚ å¦‚æœå…ƒç´ å±äºé›†åˆï¼Œåˆ™å®ƒè¿”å›ç¡®åˆ‡çš„è¿­ä»£å™¨ä½ç½®ï¼Œå¦åˆ™è¿”å›set.end() ã€‚
```





```
class Solution {
    vector<vector<int> > result;
    vector<int>path;
public:
    void back(vector<int> &nums,int start)
    {
        if(path.size()>1)result.push_back(path);
        //æ¯ä¸€å±‚éƒ½å¼€ä¸€ä¸ªsetå»é‡
        unordered_set<int> use;
        for(int i=start;i<nums.size();++i)
        {
            //åŒä¸€å±‚å…ƒç´ ä¸èƒ½é‡å¤
            if(!path.empty()&&nums[i]<path.back()||use.find(nums[i])!=use.end())continue;
            path.push_back(nums[i]);
            use.insert(nums[i]);//è®°å½•è¯¥å…ƒç´ æœ¬å±‚ä½¿ç”¨è¿‡
            back(nums,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        back(nums,0);
        return result;
    }
};
```



### 13.å…¨æ’åˆ—â…¡

ç»™å®šä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ— nums ï¼ŒæŒ‰ä»»æ„é¡ºåº è¿”å›æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—ã€‚

 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šnums = [1,1,2]
è¾“å‡ºï¼š
[[1,1,2],
 [1,2,1],
 [2,1,1]]

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/permutations-ii
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

![image-20220714220156651](C:\Users\boy\AppData\Roaming\Typora\typora-user-images\image-20220714220156651.png)



[1,12]è¯¥æ•°ç»„é€‰å–ç¬¬ä¸€ä¸ªå¼€å¤´å’Œé€‰å–ç¬¬äºŒä¸ªå¼€å¤´ï¼Œæ’åˆ—æ˜¯ä¸€æ ·çš„ï¼Œ

1	1	2

â€‹	  2	 1

1	2	 1

â€‹	  1	 2

ä¸€ä¸ªçˆ¶èŠ‚ç‚¹çš„ä¸€å±‚ä¸èƒ½é‡å¤ã€‚

ä¸ºä»€ä¹ˆuse[i-1]==false ?

å› ä¸ºåŒä¸€å±‚use[i-1]æ‰ä¸ºfalse





```c++
class Solution {
private:
    vector<vector<int> > result;
    vector<int> path;
public:
    void back(vector<int> &nums,int num,vector<bool> &use)
    {
        if(path.size()>=nums.size())
        {
            result.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();++i)
        {
            //use[i]==trueæ˜¯ä»è¯¥æ•°ç»„ä¸­é€‰å‡ºæ¥çš„æ•°ä¸èƒ½é‡å¤
            //i>0&&nums[i]==nums[i-1]&&use[i-1]==falseæ˜¯è¯¥æ ‘æ ¹çš„è¿™ä¸€å±‚ä¸èƒ½é‡å¤ï¼Œ
            if(use[i]==true||i>0&&nums[i]==nums[i-1]&&use[i-1]==true)continue;
            use[i]=true;
            path.push_back(nums[i]);
            back(nums,i+1,use);
            use[i]=false;
            path.pop_back();
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(),nums.end());
        vector<bool> use(nums.size(),false);
        back(nums,0,use);
        return result;
    }
};
```









# äºŒåˆ†

### 1.åƒé¦™è•‰çš„ç‚ç‚



ç‚ç‚å–œæ¬¢åƒé¦™è•‰ã€‚è¿™é‡Œæœ‰ n å †é¦™è•‰ï¼Œç¬¬ i å †ä¸­æœ‰ piles[i] æ ¹é¦™è•‰ã€‚è­¦å«å·²ç»ç¦»å¼€äº†ï¼Œå°†åœ¨ h å°æ—¶åå›æ¥ã€‚

ç‚ç‚å¯ä»¥å†³å®šå¥¹åƒé¦™è•‰çš„é€Ÿåº¦ k ï¼ˆå•ä½ï¼šæ ¹/å°æ—¶ï¼‰ã€‚æ¯ä¸ªå°æ—¶ï¼Œå¥¹å°†ä¼šé€‰æ‹©ä¸€å †é¦™è•‰ï¼Œä»ä¸­åƒæ‰ k æ ¹ã€‚å¦‚æœè¿™å †é¦™è•‰å°‘äº k æ ¹ï¼Œå¥¹å°†åƒæ‰è¿™å †çš„æ‰€æœ‰é¦™è•‰ï¼Œç„¶åè¿™ä¸€å°æ—¶å†…ä¸ä¼šå†åƒæ›´å¤šçš„é¦™è•‰ã€‚  

ç‚ç‚å–œæ¬¢æ…¢æ…¢åƒï¼Œä½†ä»ç„¶æƒ³åœ¨è­¦å«å›æ¥å‰åƒæ‰æ‰€æœ‰çš„é¦™è•‰ã€‚

è¿”å›å¥¹å¯ä»¥åœ¨ h å°æ—¶å†…åƒæ‰æ‰€æœ‰é¦™è•‰çš„æœ€å°é€Ÿåº¦ kï¼ˆk ä¸ºæ•´æ•°ï¼‰ã€‚

 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼špiles = [3,6,7,11], h = 8
è¾“å‡ºï¼š4



```
class Solution {
    //äºŒåˆ† å…ˆæ‰¾å‡ºæœ€å¤§å€¼ï¼Œé€æ¸äºŒåˆ†
private:
    //è®¡ç®—å…¨éƒ¨åƒå®Œéœ€è¦çš„æ—¶é—´
    int check(vector<int>&piles,int k){
        int ans=0;
        for(int i=0;i<piles.size();++i){
            ans+=piles[i]/k;
            if(piles[i]%k)ans++;
        };
        return ans;
    }

public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int max=-1;
        for(int i=0;i<piles.size();++i)max=max<piles[i]?piles[i]:max;
        int l=1,r=max;
        int mid=-1;
        while(l<r){
            mid=l+(r-l)/2;
            //èƒ½å…¨éƒ¨åƒå®Œï¼Œå¯»æ‰¾æ›´æ…¢çš„
            if(check(piles,mid)<=h)r=mid;
            else l=mid+1;
        }
        return r;
    }
};
```





# åŠ¨æ€è§„åˆ’



### 1.æ—‹è½¬å‡½æ•°(ä¸­ç­‰)

ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•´æ•°æ•°ç»„ nums ã€‚

å‡è®¾ arrk æ˜¯æ•°ç»„ nums é¡ºæ—¶é’ˆæ—‹è½¬ k ä¸ªä½ç½®åçš„æ•°ç»„ï¼Œæˆ‘ä»¬å®šä¹‰ nums çš„ æ—‹è½¬å‡½æ•°  F ä¸ºï¼š

F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]
è¿”å› F(0), F(1), ..., F(n-1)ä¸­çš„æœ€å¤§å€¼ ã€‚

ç”Ÿæˆçš„æµ‹è¯•ç”¨ä¾‹è®©ç­”æ¡ˆç¬¦åˆ 32 ä½ æ•´æ•°ã€‚

 

ç¤ºä¾‹ 1:

è¾“å…¥: nums = [4,3,2,6]
è¾“å‡º: 26
è§£é‡Š:
F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
æ‰€ä»¥ F(0), F(1), F(2), F(3) ä¸­çš„æœ€å¤§å€¼æ˜¯ F(3) = 26 ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/rotate-function





åŠ¨æ€è§„åˆ’ç±»é¢˜ç›®ä¸€å®šè¦ç”»å›¾ï¼Œäº²è‡ªæ¨å¯¼å…¬å¼



```
/*
    dp
    å…¬å¼ï¼š F(n) = F(n-1) + sum - numsSize*f(numsSize - n)
*/



int maxRotateFunction(int* nums, int numsSize){
    double max=0,sum=0;
    for(int i=0;i<numsSize;++i){
        sum+=nums[i];
        max+=i*nums[i];
    }
    double ans=max;
    for(int i=1;i<numsSize;++i){
    	//å…¬å¼
        double cur=max+sum-numsSize*nums[numsSize-i];
        max=cur;
        if(cur>ans)ans=cur;
    }
    return  ans;
}
```



æ‰¾è§„å¾‹è¿‡ç¨‹

![e4b12aaa239e101aff4bcca79853760.jpg](https://pic.leetcode-cn.com/1650608674-vOmbUR-e4b12aaa239e101aff4bcca79853760.jpg)















# KMP

### 1.ç»å…¸strStr

```
/*
    KMPç®—æ³•
    æ‰¾æœ€é•¿ç›¸ç­‰å‰åç¼€ï¼Œå›é€€
*/
void getnext(int *next,char *needle){
    int j=0;
    next[0]=0;
    for(int i=1;i<strlen(needle);++i){
        //ä¸ç›¸ç­‰å°±å›é€€
        while(j>0&&needle[i]!=needle[j]){
            j=next[j-1];
        }
        //ç›¸ç­‰å°±ç»§ç»­å¯»æ‰¾
        if(needle[i]==needle[j])j++;
        //æ›´æ–°nextæ•°ç»„
        next[i]=j;
    }
}
int strStr(char * haystack, char * needle){
    if(strlen(needle)==0)return 0;
    else if(strlen(haystack)==0)return -1;
    int next[strlen(needle)];
    getnext(next,needle); 
    for(int i=0,j=0;i<strlen(haystack);++i){
        //ä¸åŒ¹é…å°±å›é€€
        while(j>0&&haystack[i]!=needle[j])j=next[j-1];
        //åŒ¹é…
        if(haystack[i]==needle[j]){
            if(j==strlen(needle)-1)return i-j;
            j++;
        }
   }
   return -1;
}
```









# ä½è¿ç®—



```
# bitæ“ä½œ
& ç¬¦å·ï¼Œx & y ï¼Œä¼šå°†ä¸¤ä¸ªåè¿›åˆ¶æ•°åœ¨äºŒè¿›åˆ¶ä¸‹è¿›è¡Œä¸è¿ç®—
| ç¬¦å·ï¼Œx | y ï¼Œä¼šå°†ä¸¤ä¸ªåè¿›åˆ¶æ•°åœ¨äºŒè¿›åˆ¶ä¸‹è¿›è¡Œæˆ–è¿ç®—
^ ç¬¦å·ï¼Œx ^ y ï¼Œä¼šå°†ä¸¤ä¸ªåè¿›åˆ¶æ•°åœ¨äºŒè¿›åˆ¶ä¸‹è¿›è¡Œå¼‚æˆ–è¿ç®—
<< ç¬¦å·ï¼Œx << y å·¦ç§»æ“ä½œï¼Œæœ€å³è¾¹ç”¨ 0 å¡«å……
>> ç¬¦å·ï¼Œx >> y å³ç§»æ“ä½œï¼Œæœ€å·¦è¾¹ç”¨ 0 å¡«å……
~ ç¬¦å·ï¼Œ~x ï¼ŒæŒ‰ä½å–åæ“ä½œï¼Œå°† x åœ¨äºŒè¿›åˆ¶ä¸‹çš„æ¯ä¸€ä½å–å

# æ•´æ•°é›†åˆsetä½è¿ç®—
# æ•´æ•°é›†åˆåšæ ‡å¿—æ—¶ï¼Œæ¯”å¦‚å›æº¯æ—¶çš„visitedæ ‡å¿—æ•°ç»„
vstd è®¿é—® i ï¼švstd | (1 << i)
vstd ç¦»å¼€ i ï¼švstd & ~(1 << i)
vstd ä¸åŒ…å« i : not vstd & (1 << i)

å¹¶é›† ï¼šA | B
äº¤é›† ï¼šA & B
å…¨é›† ï¼š(1 << n) - 1
è¡¥é›† ï¼š((1 << n) - 1) ^ A
å­é›† ï¼š(A & B) == B
åˆ¤æ–­æ˜¯å¦æ˜¯ 2 çš„å¹‚ ï¼šA & (A - 1) == 0
æœ€ä½ä½çš„ 1 å˜ä¸º 0 ï¼šn &= (n - 1)
æœ€ä½ä½çš„ 1ï¼šA & (-A)ï¼Œæœ€ä½ä½çš„ 1 ä¸€èˆ¬è®°ä¸º lowbit(A)
```

















### 1.ä½1çš„ä¸ªæ•°(simple)



 

```
int hammingWeight(uint32_t n) {
    int cnt=0;
    while(n){
        cnt+=(n&1);//æ¯æ¬¡åˆ¤æ–­æœ€åä¸€ä½æ˜¯1è¿˜æ˜¯0
        n>>=1;//å³ç§»ä¸€ä½
    }
    return cnt;
}
```

### 2.äºŒè¿›åˆ¶è¡¨ç¤ºä¸­è´¨æ•°ä¸ªè®¡ç®—ç½®ä½



ç»™ä½ ä¸¤ä¸ªæ•´æ•° left å’Œ right ï¼Œåœ¨é—­åŒºé—´ [left, right] èŒƒå›´å†…ï¼Œç»Ÿè®¡å¹¶è¿”å› è®¡ç®—ç½®ä½ä½æ•°ä¸ºè´¨æ•° çš„æ•´æ•°ä¸ªæ•°ã€‚

è®¡ç®—ç½®ä½ä½æ•° å°±æ˜¯äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ 1 çš„ä¸ªæ•°ã€‚

ä¾‹å¦‚ï¼Œ 21 çš„äºŒè¿›åˆ¶è¡¨ç¤º 10101 æœ‰ 3 ä¸ªè®¡ç®—ç½®ä½ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚



æ‰“è¡¨ï¼Œintæœ€å¤š32ä¸ª 1 



```
bool judge(int n){
    if(n==2||n==3||n==5||n==7||n==11||n==13||n==17||n==19)
    return true;
    else 
    return false;
}

int countPrimeSetBits(int left, int right){
    int ans=0;
    for(int i=left;i<=right;++i){
        int cnt=0;
        int j=i;
        while(j){
            if(j&1==1)cnt++;
            j>>=1;
        }
        if(judge(cnt))ans++;
    }
    return ans;
}
```



### 3.äºŒè¿›åˆ¶é—´è·



ç»™å®šä¸€ä¸ªæ­£æ•´æ•° nï¼Œæ‰¾åˆ°å¹¶è¿”å› n çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ä¸¤ä¸ª ç›¸é‚» 1 ä¹‹é—´çš„ æœ€é•¿è·ç¦» ã€‚å¦‚æœä¸å­˜åœ¨ä¸¤ä¸ªç›¸é‚»çš„ 1ï¼Œè¿”å› 0 ã€‚

å¦‚æœåªæœ‰ 0 å°†ä¸¤ä¸ª 1 åˆ†éš”å¼€ï¼ˆå¯èƒ½ä¸å­˜åœ¨ 0 ï¼‰ï¼Œåˆ™è®¤ä¸ºè¿™ä¸¤ä¸ª 1 å½¼æ­¤ ç›¸é‚» ã€‚ä¸¤ä¸ª 1 ä¹‹é—´çš„è·ç¦»æ˜¯å®ƒä»¬çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ä½ç½®çš„ç»å¯¹å·®ã€‚ä¾‹å¦‚ï¼Œ"1001" ä¸­çš„ä¸¤ä¸ª 1 çš„è·ç¦»ä¸º 3 ã€‚

 

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/binary-gap
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚





```
class Solution {
public:
    int binaryGap(int n) {
        int i=0,pre=0,falg=0;
        int count=0,maxcount=0;
        while(n){
            int a=n&1;
            //å…ˆæ‰¾åˆ°ç¬¬ä¸€ä¸ª1çš„ä½ç½®å¹¶è®°å½•
            if(a==1&&falg==0){
                pre=i;
                falg=1;
            }
            //iå‘åèµ°é‡è§1å°±è®¡ç®—è·ç¦»
            if(a==1&&falg==1){
                count=i-pre;
                pre=i;
            }
            i++;
            if(count>maxcount)maxcount=count;
            n=n>>1;
        }
        return maxcount;
    }
};
```





# å…¶ä»–é¢˜ç›®

### 1.å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°(å›°éš¾)

ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦åº”è¯¥ä¸º `O(log (m+n))` ã€‚

```
è¾“å…¥ï¼šnums1 = [1,3], nums2 = [2]
è¾“å‡ºï¼š2.00000
è§£é‡Šï¼šåˆå¹¶æ•°ç»„ = [1,2,3] ï¼Œä¸­ä½æ•° 2
```



```c
/*
åˆå¹¶+æ’åº
*/
int comp(void *a, void*b)
{
    return *(int*)a-*(int*)b;
}
double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){
    int a[nums1Size+nums2Size];//å®šä¹‰æ–°æ•°ç»„

    for(int i=0;i<nums1Size;++i)a[i]=nums1[i];
    for(int i=nums1Size,j=0;i<nums1Size+nums2Size;++i)a[i]=nums2[j++];

    qsort(a,nums1Size+nums2Size,sizeof(int),comp);//åˆå¹¶æ•°ç»„å¹¶æ’åº
    
    if((nums1Size+nums2Size)%2==0)return (float)(a[(nums1Size+nums2Size)/2]+a[(nums1Size+nums2Size)/2-1])/2;
    else return (float)a[(nums1Size+nums2Size)/2];
}
```



### 2.æœ€é•¿å›æ–‡å­ä¸²(ä¸­ç­‰)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s`ï¼Œæ‰¾åˆ° `s` ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚

```
è¾“å…¥ï¼šs = "babad"
è¾“å‡ºï¼š"bab"
è§£é‡Šï¼š"aba" åŒæ ·æ˜¯ç¬¦åˆé¢˜æ„çš„ç­”æ¡ˆã€‚
```



è§£é¢˜æ€è·¯
ï¼ˆä¸­å¿ƒæ‰©æ•£æ³•ï¼‰

â€‹	1.å®šä¹‰leftã€rightã€indexå½“ä½œæŒ‡é’ˆï¼Œleftè¡¨ç¤ºå­—ç¬¦ä¸²å¼€å§‹ä¸‹æ ‡ï¼Œå‘å·¦ç§»ï¼›rightè¡¨ç¤ºå­—ç¬¦ä¸²ç»“æŸä¸‹æ ‡ï¼Œå‘å³ç§»;indexè¡¨ç¤ºå½“å‰ä¸­å¿ƒï¼Œå‘å³ç§»åŠ¨ã€‚
â€‹	2.å¦‚æœå­—ç¬¦ä¸²é•¿åº¦ä¸º0æˆ–1ï¼Œç›´æ¥è¿”å›sï¼›
â€‹	3.åˆå§‹åŒ–maxè¡¨ç¤ºå­—ç¬¦ä¸²é•¿åº¦ = 1ï¼Œstart = 0ï¼Œindex = 0ï¼›
â€‹	4.å®šä¹‰*strç”¨äºè¡¨ç¤ºè¿”å›ä¸²
â€‹	5.indexå³ç§»ï¼Œå½“index < length - 1æ—¶å¾ªç¯ï¼š
â€‹	6.åˆå§‹åŒ–left = right = index,
â€‹	7.å½“s[right + 1] == s[index++]æ—¶ï¼ˆæœ‰abbbæƒ…å†µï¼‰r++,ä¸­å¿ƒæŒ‡é’ˆindexå³ç§»ï¼›rightæ— æ³•å³ç§»æ—¶é€€å‡ºæœ¬å±‚å¾ªç¯ï¼›
â€‹	8.left,rightæ»¡è¶³æ¡ä»¶æ—¶ï¼ˆåœ¨ä¸²å†…ï¼‰ï¼Œæ¯”è¾ƒs[left - 1] ä¸ s[right + 1]ï¼Œå¦‚æœæˆç«‹ï¼Œåˆ†åˆ«å¾€ä¸¤è¾¹ç§»åŠ¨ï¼›
â€‹	9.è®¡ç®—æœ€å¤§å€¼åŠèµ·å§‹ä¸‹æ ‡ï¼Œå¼€è¾Ÿç©ºé—´å°†å­—ç¬¦ä¸²æœ€ååŠ â€˜0â€™ç»“å°¾ï¼Œè¿”å›strã€‚

é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/longest-palindromic-substring/solution/leetcode5zui-chang-hui-wen-zi-chuan-by-y-box4/

```c
/*
ç”¨ä¸­å¿ƒæ‰©æ•£æ³•
    æ‰¾åˆ°ä¸€ä¸ªæ•°ï¼Œç„¶åå·¦å³æ‰©æ•£ï¼Œå¦‚æœå·¦è¾¹çš„æ•°ç­‰äºå³è¾¹ï¼Œå°±ç»§ç»­æ‰©æ•£
    æ¯æ¬¡è®°å½•æœ€å¤§å€¼
*/
char * longestPalindrome(char * s){
    int len=strlen(s);
    if(len==0||len==1)return s;

    int max=1,start=0;
    int left=0,right=0,idex=0;
    char*str;
    while(idex<len-1){
        left=right=idex;

        while(s[idex++]==s[right+1]){ //å¦‚æœè¿ç»­ç›¸ç­‰å°±åªç§»åŠ¨å³è¾¹
            if(++right==len-1)break;
        }

        while( (left>0)&& (right<len-1) && (s[left-1]==s[right+1]) ){//ä¸­å¿ƒæ‰©æ•£
            left--;
            right++;
        }

        if(right-left+1>max){//æ¯æ¬¡è®°å½•æœ€å¤§å€¼
            start=left;
            max=right-left+1;
        }
    }
    str=malloc(max+1);//ç•™å‡ºä¸€ä¸ª'/0'
    strncpy(str,s+start,max);
    str[max]='\0';
    return str;
}
```



### 3.äºŒåˆ†æŸ¥ç…§(ç®€å•)



ç»™å®šä¸€ä¸ª n ä¸ªå…ƒç´ æœ‰åºçš„ï¼ˆå‡åºï¼‰æ•´å‹æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ target  ï¼Œå†™ä¸€ä¸ªå‡½æ•°æœç´¢ nums ä¸­çš„ targetï¼Œå¦‚æœç›®æ ‡å€¼å­˜åœ¨è¿”å›ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› -1ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/binary-search



```c
int search(int* nums, int numsSize, int target){
    int left=0,right=numsSize-1;
    while(left<=right){//å½“left=rightæ—¶ï¼Œä¸èƒ½é€€å‡ºã€‚åˆ«å¿˜äº†ï¼ï¼
        int mid=(left+right)/2;
        if(nums[mid]==target)return mid;
        else if(nums[mid]>target)
                right=mid-1;
        else if(nums[mid]<target)
                left=mid+1;
    }
    return -1;
}
```

#### æœç´¢æ’å…¥ä½ç½®(ç®€å•)

ç»™å®šä¸€ä¸ªæ’åºæ•°ç»„å’Œä¸€ä¸ªç›®æ ‡å€¼ï¼Œåœ¨æ•°ç»„ä¸­æ‰¾åˆ°ç›®æ ‡å€¼ï¼Œå¹¶è¿”å›å…¶ç´¢å¼•ã€‚å¦‚æœç›®æ ‡å€¼ä¸å­˜åœ¨äºæ•°ç»„ä¸­ï¼Œè¿”å›å®ƒå°†ä¼šè¢«æŒ‰é¡ºåºæ’å…¥çš„ä½ç½®ã€‚

è¯·å¿…é¡»ä½¿ç”¨æ—¶é—´å¤æ‚åº¦ä¸º O(log n) çš„ç®—æ³•ã€‚



```c
int searchInsert(int* nums, int numsSize, int target){
    int left=0,right=numsSize-1;
    while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]>target)
                right=mid-1;
        else if(nums[mid]<target)
                left=mid+1;
        else return mid;
    }
    return right+1;
}
```





### 4.é‡‡è´­æ–¹æ¡ˆ





å°åŠ›å°† N ä¸ªé›¶ä»¶çš„æŠ¥ä»·å­˜äºæ•°ç»„ numsã€‚å°åŠ›é¢„ç®—ä¸º targetï¼Œå‡å®šå°åŠ›ä»…è´­ä¹°ä¸¤ä¸ªé›¶ä»¶ï¼Œè¦æ±‚è´­ä¹°é›¶ä»¶çš„èŠ±è´¹ä¸è¶…è¿‡é¢„ç®—ï¼Œè¯·é—®ä»–æœ‰å¤šå°‘ç§é‡‡è´­æ–¹æ¡ˆã€‚

æ³¨æ„ï¼šç­”æ¡ˆéœ€è¦ä»¥ 1e9 + 7 (1000000007) ä¸ºåº•å–æ¨¡ï¼Œå¦‚ï¼šè®¡ç®—åˆå§‹ç»“æœä¸ºï¼š1000000008ï¼Œè¯·è¿”å› 1

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šnums = [2,5,3,5], target = 6

è¾“å‡ºï¼š1

è§£é‡Šï¼šé¢„ç®—å†…ä»…èƒ½è´­ä¹° nums[0] ä¸ nums[2]ã€‚

ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šnums = [2,2,1,9], target = 10

è¾“å‡ºï¼š4

è§£é‡Šï¼šç¬¦åˆé¢„ç®—çš„é‡‡è´­æ–¹æ¡ˆå¦‚ä¸‹ï¼š
nums[0] + nums[1] = 4
nums[0] + nums[2] = 3
nums[1] + nums[2] = 3
nums[2] + nums[3] = 10

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/4xy4Wx



```
/*
    æ’åºåŠ åŒæŒ‡é’ˆ
*/
int comp(const void*a,const void *b){
    return *(int*)a-*(int*)b;
}
int purchasePlans(int* nums, int numsSize, int target){
    qsort(nums,numsSize,sizeof(int),comp);
    int n=0;
    int left=0,right=numsSize-1;
    while(left<right){
        if(nums[left]+nums[right]>target)right--;
        else {
            n+=right-left;//çµé­‚---å½“nums[left]+nums[right]<=targetæ—¶ï¼Œæ‰¾åˆ°å¤šå°‘ä¸ªæ•°å’Œnumss[left]ç›¸åŠ å°äºtarget
            left++;
        }
        
        n=n%1000000007;
    }
    return n%1000000007;
}
```





### 5.(æ•°å­¦)åµŒå¥—æ•°ç»„

ç´¢å¼•ä»0å¼€å§‹é•¿åº¦ä¸ºNçš„æ•°ç»„Aï¼ŒåŒ…å«0åˆ°N - 1çš„æ‰€æœ‰æ•´æ•°ã€‚æ‰¾åˆ°æœ€å¤§çš„é›†åˆSå¹¶è¿”å›å…¶å¤§å°ï¼Œå…¶ä¸­ S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }ä¸”éµå®ˆä»¥ä¸‹çš„è§„åˆ™ã€‚

å‡è®¾é€‰æ‹©ç´¢å¼•ä¸ºiçš„å…ƒç´ A[i]ä¸ºSçš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ŒSçš„ä¸‹ä¸€ä¸ªå…ƒç´ åº”è¯¥æ˜¯A[A[i]]ï¼Œä¹‹åæ˜¯A[A[A[i]]]... ä»¥æ­¤ç±»æ¨ï¼Œä¸æ–­æ·»åŠ ç›´åˆ°Så‡ºç°é‡å¤çš„å…ƒç´ ã€‚

 

ç¤ºä¾‹ 1:

è¾“å…¥: A = [5,4,0,3,1,6,2]
è¾“å‡º: 4
è§£é‡Š: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

å…¶ä¸­ä¸€ç§æœ€é•¿çš„ S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/array-nesting
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚



ç›‘ç‹±100ä¸ªç›’å­ï¼Œæ¯ä¸ªç›’å­éƒ½æœ‰ç¼–å·

```c++
class Solution {
public:
    int arrayNesting(vector<int>& nums) {
        int max=0;
        int len=nums.size();
        for(int i=0;i<len;++i)
        {
            if(nums[i]==-1)continue;
            if(max>len/2)return max;
            int cnt=1;
            int cur=nums[i];
            int pre=i;
            while(cur!=-1&&nums[i]!=nums[cur])
            {
                nums[pre]=-1;
                pre=cur;
                cur=nums[cur];
                cnt++;
            }
            max=max>cnt?max:cnt;
        }
        return max;
    }
};
```





# çŸ¥è¯†ç‚¹

### 1.malloc



#### ä¸€ç»´æ•°ç»„

reuslt=(int * )malloc(sizeof(int) * 2);

æ³¨ï¼šmalloc æ˜¯ c è¯­è¨€ä¸­çš„åŠ¨æ€åˆ†é…å†…å­˜ï¼Œresult=(int * )malloc(sizeof(int) * 2ï¼› malloc å‡½æ•°è¿”å›çš„æ˜¯ void\* å‹ï¼Œæ‰€ä»¥è¦å¼ºåˆ¶ç±»å‹è½¬æ¢æˆ intï¼Œåœ¨å‰é¢åŠ ä¸Š (int  * )ï¼Œæ‰èƒ½ç»™æ•´å‹èµ‹å€¼ï¼Œåé¢ (sizeof(int)*2) çš„æ„æ€æ˜¯åˆ†é…ä¸¤ä¸ª int å¤§å°çš„ç©ºé—´ï¼›

#### äºŒç»´æ•°ç»„

char **a=malloc(sizeof(char * ) * (åˆ—çš„æ•°é‡));

å¯¹äºŒç»´æ•°ç»„çš„åˆ—åˆå§‹åŒ–ï¼Œè¿˜è¦å¯¹è¡Œè¿›è¡Œåˆå§‹åŒ–

for(int i=0;i<col;++i){

â€‹		a[0]=malloc(sizeof(char)*(æ¯è¡Œçš„æ•°é‡))ï¼›

}















### 2.qsort  

é“¾æ¥ï¼šhttps://leetcode-cn.com/circle/article/KBnaqU/

ä»‹ç»ä¸€ä¸‹qsortåº“å‡½æ•°
void qsort(void *arr, size_t n, size_t size, int (*cmp)(const void *, const void *))
arrè¡¨ç¤ºè¦æ’åºçš„åºåˆ—ï¼Œå¯ä»¥æ˜¯æ•°ç»„åæˆ–æŒ‡é’ˆ
nè¡¨ç¤ºarrä¸­æœ‰å¤šå°‘å¾…æ’åºçš„å…ƒç´ 
sizeè¡¨ç¤ºarrä¸­å•ä¸ªå…ƒç´ çš„å¤§å°ï¼ˆå¦‚æœæ˜¯åŠ¨æ€åˆ†é…å†…å­˜çš„åºåˆ—è¦æ³¨æ„ï¼‰
cmpè¡¨ç¤ºè‡ªå®šä¹‰çš„æ¯”è¾ƒå‡½æ•°ï¼ˆæ ¸å¿ƒï¼ï¼ï¼ï¼‰



cmpæ¡†æ¶

```
int cmp(const void *a, const void *b) {
    return;
}
```

è¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼Œcmpå…¥å‚çš„aå’Œbï¼Œæ˜¯arrä¸­çš„å…ƒç´ ï¼Œå³å¦‚æœarræ˜¯æ•°ç»„ï¼Œåˆ™aã€bè¡¨ç¤ºæŒ‡å‘æ•°ç»„ä¸­æŸä¸ªå…ƒç´ çš„æŒ‡é’ˆï¼Œå¦‚æœarræ˜¯äºŒç»´æ•°ç»„ï¼ˆæ•°ç»„çš„æ•°ç»„ï¼‰ï¼Œåˆ™aã€bè¡¨ç¤ºæŒ‡å‘arrä¸­æŸä¸ªæ•°ç»„çš„æŒ‡é’ˆ

###### ä¸€ç»´æ•°ç»„/åŠ¨æ€åˆ†é…

```
int cmp(const void *a, const void *b) {
    return *(int*)a - *(int*)b;  /* aã€båˆ†åˆ«æŒ‡å‘arr1/arr2ä¸­æŸä¸ªå…ƒç´  */
}

int main()
{
    int arr1[] = { 5, 8, 6, 1, -3, 0, 1, 4 };
    qsort(arr1, sizeof(arr1) / sizeof(arr1[0]), sizeof(arr1[0]), cmp);

    int *arr2 = (int*)calloc(8, sizeof(int));
    arr2[0] = 5; arr2[1] = 8; arr2[2] = 6; arr2[3] = 1; arr2[4] = -3; arr2[5] = 0; arr2[6] = 1; arr2[7] = 4; 
    qsort(arr2, 8, sizeof(arr2[0]), cmp);  /* å¦‚æœå°†8æ”¹æˆsizeof(arr2) / sizeof(arr2[0])ï¼Œæ’åºä¼šå¤±è´¥ */
}
```

### 3.å…³äºé“¾è¡¨çš„åˆ›å»ºé“¾æ¥é—®é¢˜

```
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    struct ListNode *head=NULL,*tail=NULL;//åˆå§‹åŒ–è¿”å›é“¾è¡¨
    head=malloc(sizeof(struct ListNode));
    head->val=1;
    head->next=NULL;
    tail=head->next;//å› ä¸ºhead->nextæ˜¯ç©ºï¼Œæ‰€ä»¥tailå˜ä¸ºç©ºï¼Œå¹¶ä¸æ˜¯head->next
    tail=malloc(sizeof(struct ListNode));
    tail->val=2;
    tail->next=NULL;
    //head->next=tail;
    return head;
}
```

è¾“å‡º[1]

é—®é¢˜ï¼šåº”è¯¥è¾“å‡º[1,2]

â€‹			å› ä¸ºhead->nextæ˜¯ç©ºï¼Œæ‰€ä»¥tailå˜ä¸ºç©ºï¼Œå¹¶ä¸æ˜¯head->next



### 4.strcpyå’Œstrncpy

å¤´æ–‡ä»¶ï¼š#include <string.h>
strcpy() å‡½æ•°ç”¨æ¥å¤åˆ¶å­—ç¬¦ä¸²ï¼Œå…¶åŸå‹ä¸ºï¼š
char *strcpy(char *dest, const char *src);
ã€å‚æ•°ã€‘dest ä¸ºç›®æ ‡å­—ç¬¦ä¸²æŒ‡é’ˆï¼Œsrc ä¸ºæºå­—ç¬¦ä¸²æŒ‡é’ˆã€‚
æ³¨æ„ï¼šsrc å’Œ dest æ‰€æŒ‡çš„å†…å­˜åŒºåŸŸä¸èƒ½é‡å ï¼Œä¸”dest å¿…é¡»æœ‰è¶³å¤Ÿçš„ç©ºé—´æ”¾ç½® src æ‰€åŒ…å«çš„å­—ç¬¦ä¸²ï¼ˆåŒ…å«ç»“æŸç¬¦NULLï¼‰ã€‚
ã€è¿”å›å€¼ã€‘æˆåŠŸæ‰§è¡Œåè¿”å›ç›®æ ‡æ•°ç»„æŒ‡é’ˆ destã€‚
strcpy() æŠŠsrcæ‰€æŒ‡çš„ç”±NULLç»“æŸçš„å­—ç¬¦ä¸²å¤åˆ¶åˆ°dest æ‰€æŒ‡çš„æ•°ç»„ä¸­ï¼Œè¿”å›æŒ‡å‘ dest å­—ç¬¦ä¸²çš„èµ·å§‹åœ°å€ã€‚
æ³¨æ„ï¼šå¦‚æœå‚æ•° dest æ‰€æŒ‡çš„å†…å­˜ç©ºé—´ä¸å¤Ÿå¤§ï¼Œå¯èƒ½ä¼šé€ æˆç¼“å†²æº¢å‡º(buffer Overflow)çš„é”™è¯¯æƒ…å†µï¼Œåœ¨ç¼–å†™ç¨‹åºæ—¶è¯·ç‰¹åˆ«ç•™æ„ï¼Œæˆ–è€…ç”¨strncpy()æ¥å–ä»£ã€‚





strncpy()ç”¨æ¥å¤åˆ¶å­—ç¬¦ä¸²çš„å‰nä¸ªå­—ç¬¦ï¼Œå…¶åŸå‹ä¸ºï¼š
    char * strncpy(char *dest, const char *src, size_t n);
ã€å‚æ•°è¯´æ˜ã€‘dest ä¸ºç›®æ ‡å­—ç¬¦ä¸²æŒ‡é’ˆï¼Œsrc ä¸ºæºå­—ç¬¦ä¸²æŒ‡é’ˆã€‚
strncpy()ä¼šå°†å­—ç¬¦ä¸²srcå‰nä¸ªå­—ç¬¦æ‹·è´åˆ°å­—ç¬¦ä¸²destã€‚
ä¸åƒstrcpy()ï¼Œstrncpy()ä¸ä¼šå‘destè¿½åŠ ç»“æŸæ ‡è®°'\0'ï¼Œè¿™å°±å¼•å‘äº†å¾ˆå¤šä¸åˆå¸¸ç†çš„é—®é¢˜ï¼Œå°†åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­è¯´æ˜ã€‚

å¦‚æœsrcçš„å‰nä¸ªå­—èŠ‚ä¸å«NULLå­—ç¬¦ï¼Œåˆ™ç»“æœä¸ä¼šä»¥NULLå­—ç¬¦ç»“æŸã€‚        
å¦‚æœsrcçš„é•¿åº¦å°äºnä¸ªå­—èŠ‚ï¼Œåˆ™ä»¥NULLå¡«å……destç›´åˆ°å¤åˆ¶å®Œnä¸ªå­—èŠ‚ã€‚        
srcå’Œdestæ‰€æŒ‡å†…å­˜åŒºåŸŸä¸å¯ä»¥é‡å ä¸”destå¿…é¡»æœ‰è¶³å¤Ÿçš„ç©ºé—´æ¥å®¹çº³srcçš„å­—ç¬¦ä¸²ã€‚    
æ³¨æ„ï¼šsrc å’Œ dest æ‰€æŒ‡çš„å†…å­˜åŒºåŸŸä¸èƒ½é‡å ï¼Œä¸”dest å¿…é¡»æœ‰è¶³å¤Ÿçš„ç©ºé—´æ”¾ç½®nä¸ªå­—ç¬¦ã€‚
ã€è¿”å›å€¼ã€‘è¿”å›æŒ‡å‘destçš„æŒ‡é’ˆï¼ˆè¯¥æŒ‡å‘destçš„æœ€åä¸€ä¸ªå…ƒç´ ï¼‰ 

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/qq_26093511/article/details/73338036



ä¾‹å­ï¼šå…¶ä»–é¢˜ç›®->æœ€é•¿å›æ–‡å­ä¸²



### 5.srcmp



C åº“å‡½æ•° **int strcmp(const char \*str1, const char \*str2)** æŠŠ **str1** æ‰€æŒ‡å‘çš„å­—ç¬¦ä¸²å’Œ **str2** æ‰€æŒ‡å‘çš„å­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒã€‚



- å¦‚æœè¿”å›å€¼å°äº 0ï¼Œåˆ™è¡¨ç¤º str1 å°äº str2ã€‚
- å¦‚æœè¿”å›å€¼å¤§äº 0ï¼Œåˆ™è¡¨ç¤º str1 å¤§äº str2ã€‚
- å¦‚æœè¿”å›å€¼ç­‰äº 0ï¼Œåˆ™è¡¨ç¤º str1 ç­‰äº str2ã€‚



### 6.å­—ç¬¦ä¸²

å­—ç¬¦ä¸²çš„å­—ä¸²



**å¯¹äºä¸€ä¸ªå­—ç¬¦ä¸²å˜é‡ï¼Œä¾‹å¦‚"adereegfbw",å®ƒçš„å­ä¸²å°±æ˜¯åƒ"ader"è¿™æ ·å¯ä»¥ä»ä¸­æ‰¾åˆ°çš„è¿ç»­çš„å­—ç¬¦ä¸²ã€‚å­—ç¬¦ä¸²"adereegfbw"æœ¬èº«ä¹Ÿå±äºå®ƒæœ¬èº«æœ€é•¿çš„å­ä¸²ã€‚**

#### cè¯­è¨€ atoiå‡½æ•°

#### (å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°)

å‡½æ•°è¯´æ˜ atoi()ä¼šæ‰«æå‚æ•°nptrå­—ç¬¦ä¸²ï¼Œè·³è¿‡å‰é¢çš„ç©ºæ ¼å­—ç¬¦ï¼Œç›´åˆ°é‡ä¸Šæ•°å­—æˆ–æ­£è´Ÿç¬¦å·æ‰å¼€å§‹åšè½¬æ¢ï¼Œè€Œå†é‡åˆ°éæ•°å­—æˆ–å­—ç¬¦ä¸²ç»“æŸæ—¶('\0')æ‰ç»“æŸè½¬æ¢ï¼Œå¹¶å°†ç»“æœè¿”å›ã€‚
è¿”å›å€¼ è¿”å›è½¬æ¢åçš„æ•´å‹æ•°ã€‚

```
 int atoi(const char *nptr);
```

```
/*
* name:xif
* coder:xifan@2010@yahoo.cn
* time:08.20.2012
* file_name:my_atoi.c
* function:int my_atoi(char* pstr)
*/
 
int my_atoi(char* pstr)
{
	int Ret_Integer = 0;
	int Integer_sign = 1;
	
	/*
	* åˆ¤æ–­æŒ‡é’ˆæ˜¯å¦ä¸ºç©º
	*/
	if(pstr == NULL)
	{
		printf("Pointer is NULL\n");
		return 0;
	}
	
	/*
	* è·³è¿‡å‰é¢çš„ç©ºæ ¼å­—ç¬¦
	*/
	while(isspace(*pstr) == 0)
	{
		pstr++;
	}
	
	/*
	* åˆ¤æ–­æ­£è´Ÿå·
	* å¦‚æœæ˜¯æ­£å·ï¼ŒæŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªå­—ç¬¦
	* å¦‚æœæ˜¯ç¬¦å·ï¼ŒæŠŠç¬¦å·æ ‡è®°ä¸ºInteger_signç½®-1ï¼Œç„¶åå†æŠŠæŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªå­—ç¬¦
	*/
	if(*pstr == '-')
	{
		Integer_sign = -1;
	}
	if(*pstr == '-' || *pstr == '+')
	{
		pstr++;
	}
	
	/*
	* æŠŠæ•°å­—å­—ç¬¦ä¸²é€ä¸ªè½¬æ¢æˆæ•´æ•°ï¼Œå¹¶æŠŠæœ€åè½¬æ¢å¥½çš„æ•´æ•°èµ‹ç»™Ret_Integer
	*/
	while(*pstr >= '0' && *pstr <= '9')
	{
		Ret_Integer = Ret_Integer * 10 + *pstr - '0';
		pstr++;
	}
	Ret_Integer = Integer_sign * Ret_Integer;
	
	return Ret_Integer;
}
```





### 7.ä½è¿ç®—



| &    | ä¸   | ä¸¤ä¸ªä½éƒ½ä¸º1æ—¶ï¼Œç»“æœæ‰ä¸º1                                     |
| ---- | ---- | ------------------------------------------------------------ |
| \|   | æˆ–   | ä¸¤ä¸ªä½éƒ½ä¸º0æ—¶ï¼Œç»“æœæ‰ä¸º0                                     |
| ^    | å¼‚æˆ– | ä¸¤ä¸ªä½ç›¸åŒä¸º0ï¼Œç›¸å¼‚ä¸º1                                       |
| ~    | å–å | 0å˜1ï¼Œ1å˜0                                                   |
| <<   | å·¦ç§» | å„äºŒè¿›ä½å…¨éƒ¨å·¦ç§»è‹¥å¹²ä½ï¼Œé«˜ä½ä¸¢å¼ƒï¼Œä½ä½è¡¥0                    |
| >>   | å³ç§» | å„äºŒè¿›ä½å…¨éƒ¨å³ç§»è‹¥å¹²ä½ï¼Œå¯¹æ— ç¬¦å·æ•°ï¼Œé«˜ä½è¡¥0ï¼Œæœ‰ç¬¦å·æ•°ï¼Œå„ç¼–è¯‘å™¨å¤„ç†æ–¹æ³•ä¸ä¸€æ ·ï¼Œæœ‰çš„è¡¥ç¬¦å·ä½ï¼ˆç®—æœ¯å³ç§»ï¼‰ï¼Œæœ‰çš„è¡¥0ï¼ˆé€»è¾‘å³ç§»ï¼‰ |



### sprintfå‡½æ•°

sprintf()å‡½æ•°ç”¨äºå°†æ ¼å¼åŒ–çš„æ•°æ®å†™å…¥å­—ç¬¦ä¸²ï¼Œå…¶åŸå‹ä¸ºï¼š

# é—®é¢˜

### 1.æ³¨æ„ç»†èŠ‚

åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦å”¯ä¸€



å®ç°ä¸€ä¸ªç®—æ³•ï¼Œç¡®å®šä¸€ä¸ªå­—ç¬¦ä¸² `s` çš„æ‰€æœ‰å­—ç¬¦æ˜¯å¦å…¨éƒ½ä¸åŒã€‚

è¾“å…¥ï¼šleetcode

è¾“å‡ºï¼šfalse



è¾“å…¥ï¼šabc

è¾“å‡ºï¼štrue



**å¦‚æœæˆ‘æ˜¯é¢è¯•å®˜ï¼Œæˆ‘ä¼šå¸Œæœ›çœ‹åˆ°ä»€ä¹ˆï¼Ÿ**

**å¯èƒ½æœ‰ç‚¹åé¢˜ï¼Œæ¯•ç«Ÿè¿™é‡Œä¸»è¦å°±æ˜¯åšé¢˜çš„åœ°æ–¹ã€‚ã€‚**

**å¦‚æœæˆ‘æ˜¯é¢è¯•å®˜ï¼Œä¼šè€ƒè™‘ä¸»è¦è€ƒå¯Ÿä»€ä¹ˆï¼Œå°±æˆ‘çš„å·¥ä½œç»éªŒçœ‹ï¼Œå¤§å¤šæ•°ä¸»è¦æ˜¯æ‹›è˜å·¥ç¨‹å¸ˆçš„ï¼Œé¢è¯•è€…å¦‚æœä»€ä¹ˆé—®é¢˜éƒ½æ²¡æœ‰ï¼Œç›´æ¥å†™ä¸ªäºŒé‡å¾ªç¯æå®šï¼Œä¼šé¦–å…ˆç»™ä¸ª50åˆ†ï¼Œå¦‚æœèƒ½å†™ç‚¹åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦ä¸ºnullçš„ï¼Œ60åˆ†ã€‚**

**ç›´æ¥ä¸Šæ‰‹ä»€ä¹ˆbitsetï¼Œä»€ä¹ˆä½è¿ç®—çš„ï¼Œæˆ‘ä¼šå…ˆé—®ä»–ï¼Œé¢˜ç›®ä¸­æœ‰æ²¡æœ‰äº¤ä»£å­—ç¬¦ä¸²çš„å­—ç¬¦ä¸€å®šæ˜¯26ä¸ªè‹±æ–‡å­—æ¯ï¼Ÿå¦‚æœæ˜¯unicodeç¯å¢ƒï¼Œä½ æ˜¯ä¸æ˜¯è¦å‡†å¤‡2^16/8ä¸ªå­—èŠ‚çš„ç©ºé—´ï¼Ÿåœ¨å®é™…é¡¹ç›®ä¸­ï¼Œé£é™©å¯æ§ï¼Œç»“æœå¯æœŸæ›´é‡è¦ï¼Œç»å¤§å¤šæ•°æ—¶å€™ä¸åœ¨ä¹é‚£ç‚¹æ—¶é—´å’Œèµ„æºã€‚**

**æ‰€ä»¥æˆ‘æœŸæœ›é¢è¯•è€…ä¸è¦æ€¥äºè§£ç­”ï¼Œæˆ‘å¸Œæœ›ä»–å…ˆé—®æˆ‘é—®é¢˜ï¼š**

1. **å­—ç¬¦ä¸²çš„å­—ç¬¦èŒƒå›´ï¼Œå¦‚æœæˆ‘å‘Šè¯‰ä»–ï¼Œ26ä¸ªå°å†™è‹±æ–‡å­—æ¯ï¼Œé‚£å¯èƒ½ä¸€å¼€å¤´ç›´æ¥åˆ¤æ–­å¦‚æœå­—ç¬¦é•¿åº¦>26, ç›´æ¥è¿”å›Falseï¼Œåšåˆ°è¿™ä¸€ç‚¹çš„ï¼Œ80åˆ†**
2. **å¦‚æœæˆ‘å‘Šè¯‰ä»–asciiå­—ç¬¦é›†ï¼Œç„¶åä»–çš„ä»£ç é‡Œæœ‰è¾¹ç•Œæ£€æŸ¥ï¼Œå¹¶ä¸”é’ˆå¯¹ä¸åŒçš„èŒƒå›´æœ‰ä¸åŒçš„ä¾§é‡ç‚¹ï¼Œæ¯”å¦‚è¯´asciiå­—ç¬¦é›†ï¼Œé‚£ä¹Ÿå°±æ˜¯128ä¸ªå¯èƒ½æ€§ï¼Œ16ä¸ªå­—èŠ‚çš„ä½è¿ç®—æ¯”è¾ƒå¥½**
3. **å¦‚æœæˆ‘å‘Šè¯‰ä»–æ˜¯unicodeï¼Œæ²¡æœ‰å­—ç¬¦èŒƒå›´ï¼Œè€è€å®å®æ’åºå†åˆ¤æ–­æ˜¯æ¯”è¾ƒç¬¦åˆæˆ‘å¯¹å·¥ç¨‹å¸ˆçš„è¦æ±‚çš„ï¼Œå› ä¸ºç®—æ³•æ€§èƒ½ç¨³å®šï¼Œæ²¡æœ‰é¢å¤–èµ„æºè¦æ±‚ï¼Œä¸€çœ¼çœ‹å‡ºæ²¡ä»€ä¹ˆä¸å¯é¢„è§çš„é£é™©ï¼Œ100åˆ†ã€‚**

**å°±æ˜¯è¯´ï¼Œæœ‰äº›ä¸œè¥¿ï¼Œæ²¡æƒ³åˆ°æˆ–è€…ä¸€æ—¶æ²¡æƒ³åˆ°æ ¹æœ¬ä¸æ˜¯é—®é¢˜ï¼Œæ—¥å¸¸å·¥ä½œä¸­ç¨å¾®æç¤ºä¸€ä¸‹å³å¯ï¼Œä½†æ˜¯ç¼œå¯†çš„æ€ç»´å¯¹äºç¨‹åºå‘˜æ¥è¯´æ›´é‡è¦ã€‚**
