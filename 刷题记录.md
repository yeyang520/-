

# 数组

### 1.子数组范围和(中等)



输入：nums = [1,2,3]
输出：4
解释：nums 的 6 个子数组如下所示：
[1]，范围 = 最大 - 最小 = 1 - 1 = 0 
[2]，范围 = 2 - 2 = 0
[3]，范围 = 3 - 3 = 0
[1,2]，范围 = 2 - 1 = 1
[2,3]，范围 = 3 - 2 = 1
[1,2,3]，范围 = 3 - 1 = 2
所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4



**思路：迭代的计算出每次子序列的最大值和最小值并保存**

```
long long subArrayRanges(int* nums, int numsSize){
    double sum=0;
    
    for(int i=0;i<numsSize;++i){
        int max=nums[i],min=nums[i];
        for(int j=i+1;j<numsSize;++j){
            max=max>nums[j]?max:nums[j];
            min=min<nums[j]?min:nums[j];
            sum+=max-min;
        }
    }
    return sum;
}
```



### 2.杨辉三角形(简单)

```
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** generate(int numRows, int* returnSize, int** returnColumnSizes){
    *returnSize=numRows;
    *returnColumnSizes=malloc(sizeof(int)*numRows);
    
    int **a=malloc(sizeof(int*)*numRows);//返回的数组指针

    for(int i=0;i<numRows;++i){
        a[i]=malloc(sizeof(int)*(i+1));
        (*returnColumnSizes)[i]=i+1;
        a[i][0]=a[i][i]=1;

        for(int j=1;j<i;++j){
            a[i][j]=a[i-1][j-1]+a[i-1][j];
        }

    }
    return a;
}
```



### 3.加一(简单)



```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 /*
    分情况进行讨论
    1.不用进位
    2.进位
    3.进位且需要开辟新空间
 */
int* plusOne(int* digits, int digitsSize, int* returnSize){
    if(digits[digitsSize-1]!=9){//第一种情况
        digits[digitsSize-1]++;
        *returnSize=digitsSize;
        return digits;
    }
    else{
        for(int i=digitsSize-1;i>=0;--i){//从后往前查照
            if(digits[i]!=9){
                digits[i]++;
                *returnSize=digitsSize;
                return digits;//如果发现不是全部为9就进一位然后返回原数组
            }
            else digits[i]=0;
        }
        //第三种：开辟新空间，将第一个为1，后面全部为0
        int *result=(int*)malloc(sizeof(int)*(digitsSize+1));
        result[0]=1;
        int cnt=0;
        *returnSize=digitsSize+1;
        for(int i=1;i<=digitsSize;++i)result[i]=0;
        return result;
    }
    
}
```





### 3.简易银行系统(算简单吧)





```
/*
    银行系统   数组 顺序表
*/
typedef struct  bank{
    long long  * accoun;
    int max;
} Bank;


Bank* bankCreate(long long* balance, int balanceSize) {
    Bank *bal=(Bank*)malloc(sizeof(struct bank));
    bal->accoun=(long long*)malloc(sizeof(long long)*balanceSize);
    bal->max=balanceSize;
    for(int i=0;i<balanceSize;++i)bal->accoun[i]=balance[i];
    return bal;
}
//转账
bool bankTransfer(Bank* obj, int account1, int account2, long long money) {
    if(account1>obj->max||account2>obj->max||obj->accoun[account1-1]<money)return false;
    obj->accoun[account1-1]-=money;
    obj->accoun[account2-1]+=money;
    return true;
}
//存钱  
bool bankDeposit(Bank* obj, int account, long long money) {
    if(account>obj->max||account<0)return false;
    obj->accoun[account-1]+=money;
    return true;
}
//取钱
bool bankWithdraw(Bank* obj, int account, long long money) {
    if(account>obj->max||obj->accoun[account-1]<money)return false;
    obj->accoun[account-1]-=money;
    return true;
}

void bankFree(Bank* obj) {
    free(obj->accoun);
}

/**
 * Your Bank struct will be instantiated and called as such:
 * Bank* obj = bankCreate(balance, balanceSize);
 * bool param_1 = bankTransfer(obj, account1, account2, money);
 
 * bool param_2 = bankDeposit(obj, account, money);
 
 * bool param_3 = bankWithdraw(obj, account, money);
 
 * bankFree(obj);
*/
```



### 4.最接近的三数之和(medium)



给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

 

示例 1：

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
示例 2：

输入：nums = [0,0,0], target = 1
输出：0

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/3sum-closest





```
int comp(const void*a,const void *b){
    return *(int*)a-*(int*)b;
}
int threeSumClosest(int* nums, int numsSize, int target){
    //排序 双指针
    
    qsort(nums,numsSize,sizeof(int),comp);
    int ans=nums[0]+nums[1]+nums[2];
    for(int i=0;i<numsSize-2;++i){
        int left=i+1,right=numsSize-1;
        while(left<right){
            int sum=nums[i]+nums[left]+nums[right];
            if(abs(sum-target)<abs(ans-target)){
                ans=sum;
                //printf("%d %d %d   ",nums[i],nums[left],nums[right]);
            }
            else if(sum>target)right--;
            else if(sum<target)left++;
            else return target;
        }
    }
    return ans;
}
```







### 5.螺旋矩阵(medium)



```
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes){
    int idex=1;
    int left=0;
    int right=n-1;
    int up=0;
    int down=n-1;
    *returnColumnSizes=(int*)malloc(sizeof(int)*n);
    *returnSize=n;
    int **ans=(int**)malloc(sizeof(int*)*n);
    for(int i=0;i<n;++i){
        ans[i]=(int*)malloc(sizeof(int)*n);
        (*returnColumnSizes)[i]=n;
    }
    while(up<=down&&left<=right){
        for(int i=left;i<=right;++i)ans[up][i]=idex++;//👆
        up++;
        for(int i=up;i<=down;++i)ans[i][right]=idex++;//👉
        right--;
        for(int i=right;i>=left&&up<=down;--i)ans[down][i]=idex++;//👈
        down--;
        for(int i=down;i>=up&&left<=right;--i)ans[i][left]=idex++;//👇
        left++;
    }
    return ans;
}
```



### 6.前K个高频元素(medium)



给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

 

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/top-k-frequent-elements





```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 /*
    快速排序
    将数组及次数放入结构体，对结构体进行排序。返回前k个
 */
 
 //建立结构体
 struct time{
     int val;
     int cnt;
 };
 //数组排序
 int comp(const void*a,const void*b){
     return *(int*)a-*(int*)b;
 }
 //结构体排序
 int compstruct(const void *a,const void*b){
     return (*(struct time*)b).cnt-(*(struct time*)a).cnt;
 }
int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){
    //对数组进行排序
    qsort(nums,numsSize,sizeof(int),comp);
    //结构体数组
    struct time a[numsSize];
    int j=0;
    a[0].val=nums[0];
    a[0].cnt=1;
    //将数组放入结构体
    for(int i=1;i<numsSize;++i){
        if(nums[i]==a[j].val){
            a[j].cnt++;
        }
        else{
            j++;
            a[j].val=nums[i];
            a[j].cnt=1;
        }
    }
    //对结构体进行排序
    qsort(a,j+1,sizeof(struct time),compstruct);
    //构造返回数组
    int *result=(int*)malloc(sizeof(int)*k);
    for(int i=0;i<k;++i){
        result[i]=a[i].val;
    }
    *returnSize=k;
    return result;
}
```



### 7.求三角形的最大周长(简单)



给定由一些正数（代表长度）组成的数组 `nums` ，返回 *由其中三个长度组成的、**面积不为零**的三角形的最大周长* 。如果不能形成任何面积不为零的三角形，返回 `0`。



```
/*
    排序
    查照，看是否符合
*/
int comp(const void*a,const void*b){
    return *(int*)b-*(int*)a;
}
int largestPerimeter(int* nums, int numsSize){
    qsort(nums,numsSize,sizeof(int),comp);
    for(int i=2;i<numsSize;++i){
        if(nums[i-2]<nums[i-1]+nums[i])return nums[i]+nums[i-1]+nums[i-2];
    }
    return 0;
}
```



### 8.找到最近的有相同 X 或 Y 坐标的点(简单)

给你两个整数 x 和 y ，表示你在一个笛卡尔坐标系下的 (x, y) 处。同时，在同一个坐标系下给你一个数组 points ，其中 points[i] = [ai, bi] 表示在 (ai, bi) 处有一个点。当一个点与你所在的位置有相同的 x 坐标或者相同的 y 坐标时，我们称这个点是 有效的 。

请返回距离你当前位置 曼哈顿距离 最近的 有效 点的下标（下标从 0 开始）。如果有多个最近的有效点，请返回下标 最小 的一个。如果没有有效点，请返回 -1 。

两个点 (x1, y1) 和 (x2, y2) 之间的 曼哈顿距离 为 abs(x1 - x2) + abs(y1 - y2) 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate





每次计算出距离来，如果更小就更新答案



```
int nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){
    int a=INT_MAX;
    int ans=-1;
    for(int i=0;i<pointsSize;++i){
        if(x==points[i][0]||y==points[i][1]){
            int sum=abs(x-points[i][0])+abs(y-points[i][1]);
            if(sum<a){
                a=sum;
                ans=i;
            }
        }
    }
    return ans;
}
```



### 9.图片平滑器(简单)



图像平滑器 是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。

每个单元格的  平均灰度 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。

如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/image-smoother



```
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
/*
    暴力搜索
 */
 int get(int**img,int row,int col,int maxCol,int maxRow){
     int sum=0;
     int count=0;
     for(int i=row-1;i<=row+1;++i){
         if(i<0||i>=maxRow)continue;
         for(int j=col-1;j<=col+1;++j){
             if(j<0||j>=maxCol)continue;
                 sum+=img[i][j];
                 count++;
         }
     }
     return sum/count;
 }
int** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes){
    int maxRow=imgSize;
    int maxCol=imgColSize[0];
    *returnSize=maxRow;
    //返回的指针
    *returnColumnSizes=(int*)malloc(sizeof(int)*maxRow);
    //返回数组
    int **result=(int**)malloc(sizeof(int*)*maxRow);
    //爆搜
    int sum=0;
    for(int i=0;i<maxRow;++i){
        //分配空间
        (*returnColumnSizes)[i]=maxCol;
        result[i]=(int*)malloc(sizeof(int)*maxCol);
        for(int j=0;j<maxCol;++j){
            result[i][j]=get(img,i,j,maxCol,maxRow);
        }
    }
    return result;
}
```



### 10.缀点成线(简单)



```
/*
    看斜率，防止分母出现零，用乘法
*/
bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize){
    int x1=coordinates[1][0]-coordinates[0][0],y1=coordinates[1][1]-coordinates[0][1];
    for(int i=2;i<coordinatesSize;++i){
        int x2=coordinates[i][0]-coordinates[i-1][0],y2=coordinates[i][1]-coordinates[i-1][1];
        if(x1*y2!=x2*y1)return false;
    }
    return true;
}
```



### 11.重塑矩阵(简单)



在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。

给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。

如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

 

示例 1：


输入：mat = [[1,2],[3,4]], r = 1, c = 4
输出：[[1,2,3,4]]
示例 2：

输入：mat = [[1,2],[3,4]], r = 2, c = 4
输出：[[1,2],[3,4]]

```
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){
    int m=matSize;//行数
    int n=matColSize[0];//该数组用来标记每一行的列数

    if(r*c!=matSize*(*matColSize)){
        *returnSize=matSize;
        *returnColumnSizes=matColSize;
        return mat;
    }//如果不对直接返回原数组

    *returnSize=r;
    *returnColumnSizes=(int*)malloc(sizeof(int)*r);
    
    int **ans=(int*)malloc(sizeof(int*)*r);//开辟指针数组，指向r行，还没有去确定大小
    for(int i=0;i<r;i++){
        (*returnColumnSizes)[i]=c;//该数组用来标记每一行的列数，新数组的列数为c
        ans[i]=(int*)malloc(sizeof(int)*c);//每一行指针指向数组空间大小
    }
    
    for (int i = 0; i < r*c; i++) {
        ans[i / c][i % c] = mat[i / n][i % n];
    }

    return ans;
}
```









# 字符串









### 1.两个列表的最小索引总和

599

```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 /*
    暴力循环
    最小索引和
 */
char ** findRestaurant(char ** list1, int list1Size, char ** list2, int list2Size, int* returnSize){
    char ** result=(char*)malloc(sizeof(char*)*list1Size);
    *returnSize=0;
    int min=INT_MAX;
    int i=0,j=0;
    for( i=0;i<list1Size;++i){
        for( j=0;j<list2Size;++j){
            if(strcmp(list1[i],list2[j])==0){
                if(i+j<min){//记录和更新最小索引和
                    *returnSize=0;
                    min=i+j;
                    result[(*returnSize)++]=list1[i];

                }
                else if(i+j==min){
                    result[(*returnSize)++]=list1[i];
                }
            }
        }
    }
    return result;
}
```





### 2.颠倒字符串中的单词(medium)

给你一个字符串 s ，颠倒字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-words-in-a-string





```
/*
    分三步
    1、去掉开头结尾的空格
        快慢指针
            让快指针走到第一个字符开始
        结尾空格
            看结尾fast为什么
                一：结尾空格：让慢指针加一结尾
                二：结尾是字符：将快指针最后一个加入后再结尾
    2.去掉中间的空格
        如果fast和fast+1为空格就fast++
    3.进行单词的反转-全部反转+逐个反转


*/
//反转函数
void reverse(char *s,int left,int right){
    while(left<right){
        char t=s[left];
        s[left++]=s[right];
        s[right--]=t;
    }
    return s;
}
char * reverseWords(char * s){
    int len=strlen(s);

    //去除开头空格
    int low=0,fast=0;
    while(s[fast]==' ')fast++;

    //去除单词中间的空格
    while(fast<(len-1)){
        if(s[fast]==' '&&s[fast+1]==' ')fast++;
        else s[low++]=s[fast++];
    }

    //结尾的空格,最后会留出一个位置
    if(s[fast]==' '){
        s[low]='\0';
    }
    else{
        s[low++]=s[fast];
        s[low]='\0';
    }
    //进行字符串反转
    reverse(s,0,low-1);
    
    //单词反转
    for(int i=0;i<low;++i){
        int j=i;
        while(j<low&&s[j]!=' ')j++;
        reverse(s,i,j-1);
        i=j++;
    }
    return s;
}
```





### 3.字符串的最短距离



```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* shortestToChar(char * s, char c, int* returnSize){
    int len=strlen(s);
    *returnSize=len;
    int *result=(int*)malloc(sizeof(int)*len);
    int idex=-2*len;
    for(int i=0;i<len;++i){
        if(s[i]==c)idex=i;
        result[i]=i-idex;
    }
    idex=2*len;
    for(int i=len-1;i>=0;--i){
        if(s[i]==c)idex=i;
        result[i]=fmin(result[i],idex-i);
    }
    return result;
}
```



### 4.最长特殊子序列

给定字符串列表 strs ，返回其中 最长的特殊序列 。如果最长特殊序列不存在，返回 -1 。

特殊序列 定义如下：该序列为某字符串 独有的子序列（即不能是其他字符串的子序列）。

 s 的 子序列可以通过删去字符串 s 中的某些字符实现。

例如，"abc" 是 "aebdc" 的子序列，因为您可以删除"aebdc"中的下划线字符来得到 "abc" 。"aebdc"的子序列还包括"aebdc"、 "aeb" 和 "" (空字符串)。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-uncommon-subsequence-ii





```c++
class Solution {
public:
/*
    双重循环，判断每一个字符串是否某个字符串的子序列。
*/
    bool IsCom(string &a,string &b)//默认b为长的序列，判断a是否为b的子序列
    {
        int i=0,j=0,cnt=0;
        while(a[i]!='\0'&&b[j]!='\0')
        {
            if(a[i]==b[j])
            {
                cnt++;
                i++;
                j++;
            }
            else j++;
        }
        return i>=a.size();
    }
    int findLUSlength(vector<string>& strs) {
        int res=-1,max=-1;
        for(int i=0;i<strs.size();++i)
        {
            int falg=1;
            for(int j=0;j<strs.size();++j)
            {
                if(i==j)continue;
                else 
                {
                    if(IsCom(strs[i],strs[j]))falg=0;
                }
            }
            if(falg==1)
            {
                res=strs[i].size();
                max=res>max?res:max;
            }
        }
        return max;
    }
};
```



# 哈希表

### 1.赎金信(简单)

给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。
链接：https://leetcode-cn.com/problems/ransom-note



思路：哈希表实现

​          1.如果ransomnote大于magazine，不可能构成。

​       	2.将magazine中所有字母进行遍历，记录出现次数，再遍历ransomnote中，如果小于0则false。

```c
bool canConstruct(char * ransomNote, char * magazine){
    int hashtab[26]={0};
    if(strlen(ransomNote)>strlen(magazine))return false;
    for(int i=0;i<strlen(magazine);++i) ++hashtab[magazine[i]-'a'];
    for(int i=0;i<strlen(ransomNote);++i)--hashtab[ransomNote[i]-'a'];
    for(int i=0;i<26;++i)if(hashtab[i]<0)return false;
    return true;
}
```

### 2.有效的字母异位词(简单)

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-anagram

思路：同上

```c
bool isAnagram(char * s, char * t){
    if(strlen(s)!=strlen(t))return false;
    int hashtab[26]={0};
    for(int i=0;i<strlen(s);++i)++hashtab[s[i]-'a'];
    for(int i=0;i<strlen(s);++i)--hashtab[t[i]-'a'];
    for(int i=0;i<26;++i)if(hashtab[i]!=0)return false;
    return true;
}
```

### 3.环形链表(简单)

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

 

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/linked-list-cycle

思路：快慢指针，一块一慢，如果相遇则为环。

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
bool hasCycle(struct ListNode *head) {
    if(head==NULL||head->next==NULL)return false;
    struct ListNode*low=head;
    struct ListNode*fast=head->next;
    while(low!=fast){
        if(fast==NULL||fast->next==NULL)return false;
        low=low->next;
        fast=fast->next->next;
    }
    return true;
}
```

**心得：在判断条件老是出现问题，快慢指针判断条件只需要判断快指针就行。**

### 4.有效的数独(中等)

请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）


注意：

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
空白格用 '.' 表示。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-sudoku

思路：笨办法，每个数组都循环用哈希表存一边并判断

```c
bool isValidSudoku(char** board, int boardSize, int* boardColSize){
    //判断行列
    for(int i=0;i<boardSize;++i){
        int hashtab1[9]={0};
        int hashtab2[9]={0};
        for(int j=0;j<boardSize;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
                ++hashtab1[board[i][j]-'0'-1];
            }
            if(board[j][i]>='1'&&board[j][i]<='9'){
                ++hashtab2[board[j][i]-'0'-1];
            }
        }
        for(int k=0;k<boardSize;++k){
            if(hashtab1[k]>1)return false;
            if(hashtab2[k]>1)return false;
        }
    }
    //判断九宫格
    //1
    int hashtab[9]={0};
    for(int i=0;i<3;++i){
        for(int j=0;j<3;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //2
    for(int i=3;i<6;++i){
        for(int j=0;j<3;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //3
    for(int i=6;i<9;++i){
        for(int j=0;j<3;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //4 
    for(int i=0;i<3;++i){
        for(int j=3;j<6;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //5
    for(int i=3;i<6;++i){
        for(int j=3;j<6;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //6
    for(int i=6;i<9;++i){
        for(int j=3;j<6;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //7
    for(int i=0;i<3;++i){
        for(int j=6;j<9;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //8
    for(int i=3;i<6;++i){
        for(int j=6;j<9;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    for(int k=0;k<9;++k)hashtab[k]=0;
    //9
    for(int i=6;i<9;++i){
        for(int j=6;j<9;++j){
            if(board[i][j]>='1'&&board[i][j]<='9'){
            ++hashtab[board[i][j]-'0'-1];
            }
        }
    }
    for(int i=0;i<9;++i)if(hashtab[i]>1)return false;
    return true;
}
```

**警示:别忘了char中数字和int中数字不一样！要用数组下标来存，得减去数字，比如'0'的ascii码为48，要存得减去'0'的48变为数字0。**

### 5.两数之和(简单)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum



思路：1.暴力法，两层循环

​			2.哈希表：在存入的同时进行一个查照。

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
/*
创建哈希表，将数组存入，边存入边查照。
*/
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    *returnSize=2;
    int *a=malloc(sizeof(int)*2);
    int hashtab[numsSize];
    for(int i=0;i<numsSize;++i){
        for(int j=0;j<i;++j){
            if(nums[hashtab[j]]==target-nums[i]){
                a[0]=hashtab[j];
                a[1]=i;
                return a;
            }
        }
        hashtab[i]=i;   
    }
    return NULL;
}
```

### 6.无重复最长字符字串(中等)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。



输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters



```c
/*
哈希表不会
滑动窗口 思路是一样的
思路：left和right，寻找新元素，遍历旧元素，如果有相同就让left变为什么？？记录最大值。
*/
int lengthOfLongestSubstring(char * s){
    int len=strlen(s);
    if(len==0||len==1)return len;
    int left=0,right=0,max=0;//定义左窗口和右窗口
    while(s[right+1]!='\0'){
        right++;
        for(int i=left;i<right;++i){//判断是否有重复元素，如果有则将左窗口移至重复元素之后
            if(s[i]==s[right]){
                left=i+1;
                break;
            }
        }
        if(right-left+1>max)max=right-left+1;
    }
    return max;
}
```





### 7.查照公用字符(简单...)



1002

示例 1：

输入：words = ["bella","label","roller"]
输出：["e","l","l"]
示例 2：

输入：words = ["cool","lock","cook"]
输出：["c","o"]



```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 /*
    思路：哈希表存储.
        用一个哈希表存储出现的最小频率
 */
char ** commonChars(char ** words, int wordsSize, int* returnSize){
    //统计第一串字符出现频率
    int hash[26]={0};
    for(int i=0;i<strlen(words[0]);++i){
        hash[words[0][i]-'a']++;
    }

    //统计其余字符串出现频率
    
    for(int i=1;i<wordsSize;++i){
        int hashother[26]={0};//每次都更新
        for(int j=0;j<strlen(words[i]);++j){
            hashother[words[i][j]-'a']++;
        }
        //刷新hash
        for(int k=0;k<26;++k)
            hash[k]=hash[k]>hashother[k]?hashother[k]:hash[k];

    }
    //求分配的空间
    int sum=0;
    for(int i=0;i<26;i++)sum+=hash[i];




    //输出
    *returnSize=0;
    char **result=malloc(sizeof(char*)*sum);
    for(int j=0;j<26;++j){
        while(hash[j]!=0){
            result[*returnSize]=malloc(sizeof(char)*2);
            result[*returnSize][0]=j+'a';
            result[*returnSize][1]='\0';//这个地方让我好找，看到力扣官方题解赋值为0，然后疯狂报错越界
            hash[j]--;
            (*returnSize)++;
        }
    }
    return result;
}
```



### 8.两数之和 IV - 输入 BST(simple)





给定一个二叉搜索树 `root` 和一个目标结果 `k`，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 `true`。



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/*
    哈希表 +两数之和
*/
void bintraverse(struct TreeNode *root,int *hash,int *j){
    //前序遍历
    if(root){
        hash[(*j)++]=root->val;
        bintraverse(root->left,hash,j);
        bintraverse(root->right,hash,j);
    }
}
int comp(const void*a,const void*b){
    return *(int*)a-*(int*)b;
}
bool findTarget(struct TreeNode* root, int k){
    int hash[10000];
    int j=0;
    bintraverse(root,hash,&j);
    //排序
    qsort(hash,j,sizeof(int),comp);
    //双指针
    int left=0,right=j-1;
    //for(int i=0;i<j;++i)printf("%d ",hash[i]);
    while(right<=j-1&&left<right){
        if(hash[left]+hash[right]==k)return true;
        else if(hash[left]+hash[right]<k)left++;
        else if(hash[left]+hash[right]>k)right--;
    }
    return false;
}
```







# 栈和队列

### 1.有效的括号(简单)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-parentheses

思路：简单栈应用

​        如果为左括号则入栈，右括号看是否与栈内相匹配，匹配则出栈，不然就false

​        当循环完后，如果栈内没有则true

```c
bool isValid(char * s){
    if(strlen(s)==0)return false;
    char a[10000]={0};
    int j=1;
    for(int i=0;i<strlen(s);++i){
        if(s[i]=='('||s[i]=='['||s[i]=='{')a[j++]=s[i];//入栈
        else if(s[i]==')'||s[i]==']'||s[i]=='}'){   //配对并出栈
            if(s[i]==')'&&a[j-1]=='('||s[i]==']'&&a[j-1]=='['||s[i]=='}'&&a[j-1]=='{')a[--j]=0; 
            else return false;
        }   
    }
        if(a[1]==0)return true;
        else return false;
}
```



### 2.删除所有相邻元素项(简单)



输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string



```
char * removeDuplicates(char * s){
    char *stack=(char*)malloc(sizeof(char)*(strlen(s)+1));
    int j=0;
    for(int i=0;i<strlen(s);++i){
        //相等就出栈
        if(j>0&&s[i]==stack[j-1]){
            j--;
        }
        //不相等入栈
        else
        stack[j++]=s[i];
    }
    stack[j]='\0';
    return stack;
}
```





### 3.逆波兰表达式(medium)



```
Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
```



```
int a(char * b){
    int sum=0,i=0;
    int sign=1;
    if(*b=='-'){
        sign=-1;
        b++;
    }
    for(i=0;b[i]!='\0';++i){
        if(b[i]>='0'&&b[i]<='9'){
            sum=sum*10+b[i]-'0';
        }
    }
    return sum*sign;
}
int evalRPN(char ** tokens, int tokensSize){
    //建立栈
    int pro[tokensSize];
    int j=0;
    for(int i=0;i<tokensSize;++i){
        char *token=tokens[i];
        //是数字就入栈
        if(token[0]>='0' &&token[0]<= '9'||strlen(token)>1){
            pro[j++]=a(token);
            //printf("%d  ",pro[j-1]);
        }
        //符号出栈做运算
        else if(token[0]=='+'||token[0]=='-'||token[0]=='*'||token[0]=='/'){
            int sum1=pro[--j];
            int sum2=pro[--j];
            //printf("%d %d  ",sum1,sum2);
            if(token[0]=='+')pro[j++]=sum1+sum2;
            else if(token[0]=='-')pro[j++]=-sum1+sum2;
            else if(token[0]=='*')pro[j++]=sum1*sum2;
            else pro[j++]=sum2/sum1;
        }
    }
    int ans=pro[0];
    return ans;
}
```





### 4.求滑动窗口最大值(difficult)



```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 /*
    队列，每次维护一个最大值
    先将前k个数放入栈中
        规则：
        1 如果压入元素大于头元素，则让所有元素出栈，该元素为头元素
        2 如果入队元素大于队尾元素就让队尾依次出队，维护单调递减队列
        3 每次都记录队列头 
    为什么要存下标？
        首先，再数组中由下标找数方便，但是由数找下标很难，存下标方标知道那个元素应该出队。
        但是，如果直接存最大元素，就无法知道什么时候那个是最大元素，什么时候应该出队。
 */
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    //排除
    *returnSize=numsSize;
    if(numsSize==0||k<2)return nums;

    int *ans=(int*)malloc(sizeof(int)*numsSize);
    *returnSize=numsSize-k+1;
    int left=0,right=0;
    //模拟队列
    int queue[numsSize];
    int i=0;
    while(i<numsSize){
        //每次窗口扫过就出队头元素
        while(left<right&&queue[left]<i-k+1)left++;
        //维护单调队列
        while(left<right&&nums[queue[right-1]]<nums[i])right--;
        //入队
        queue[right++]=i;
        if(i>=k-1)ans[i-k+1]=nums[queue[left]];
        i++;
    }
    return ans;
}
```







# 双指针

### 1.三数之和(中等)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/3sum

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
 /*
 思路：双指针
    指针left=i，right=numsSize-1
    如果三数和大于0则right--，小于0则left++
    别忘了去重（关键）
 */
 int comp(void*a,void*b){
     return *(int *)a-*(int *)b;
 }
int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    *returnSize=0;
    if(numsSize<3)return NULL;

    qsort(nums,numsSize,sizeof(int),comp);

    int **a=malloc(sizeof(int*)*numsSize*numsSize);//创建返回数组

    *returnColumnSizes=(int*)malloc(sizeof(int*)*numsSize*numsSize);
    *returnSize=0;

    for(int i=0;i<numsSize;++i){
        //已经排序，第一个大于0直接退出
        if(nums[i]>0)break;
        //去重
        if(i>0&&nums[i]==nums[i-1])continue;
        //定义左右指针
        int left=i+1;
        int right=numsSize-1;
        while(left<right){
            int sum=nums[i]+nums[left]+nums[right];
            if(sum==0){
                a[*returnSize]=(int*)malloc(sizeof(int)*3);
                a[*returnSize][0]=nums[i];
                a[*returnSize][1]=nums[left];
                a[*returnSize][2]=nums[right];
                (*returnColumnSizes)[*returnSize]=3;
                (*returnSize)++;
                //对左右指针去重
                while(left<right&&nums[left]==nums[++left]);
                while(left<right&&nums[right]==nums[--right]);
            }
            else if(sum>0)right--;
            else left++;
        }

    }
    return a;
    
}
```

**也许有些题并不是那么难，只是自己写代码的能力太弱了，还需要多加练习，也许生活就是这样吧，上天自然不会亏待了谁，努力终究会有回报，敢于面对生活中的一些困难，只有勇敢的面对，才会有美好的将来。**

### 2.盛水最多的容器(中等)

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/container-with-most-water



```c
/*
    思路：暴力求解
            循环遍历，每次记录最大水量
            .....超时了
          双指针
            左指针和右指针，每次记录最大水量
            移动数字小的指针

        为什么移动数字小的指针？
            水量=小数字 × 两指针之差
            如果移动大数字，则小的数字可能不变，但两指针之差变了，水量减少。
*/
int maxArea(int* height, int heightSize){
    int left=0,right=heightSize-1;
    int max=0;
    while(left<right){
        //算出水量
        int water=(right-left) * (height[left]>height[right]?height[right--]:height[left++]);
        if(water>max)max=water;
    }
    return max;
}
```



### 3.水果篮子(中等)



您正在参观一个农场，该农场有一排从左到右排列的果树。树由整数数组fruits表示，其中水果[i]是第i棵树产生的水果类型。 你想收集尽可能多的水果。但是，所有者有一些严格的规则，您必须遵守： 你只有两个篮子，每个篮子只能装一种水果。每篮水果的数量没有限制。 从您选择的任何一棵树开始，您必须在向右移动时从每棵树（包括起始树）中恰好摘下一个水果,摘下的水果必须放在你的一个篮子里。 一旦你到了一棵树上，树上的果实没法放入你的篮子（两个篮子已经满了），你必须停下来。 给定整数数组水果，返回可以拾取的最大水果数。 本题，其实就是选只有两个元素的最长连续子序列，比如1，2，3，2，2最长就是2，3，2，2（只包括2或者3，而且是最长的）。



示例 1：

输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
示例 2：

输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
示例 3：

输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
示例 4：

输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。



```c
int totalFruit(int* fruits, int fruitsSize){
    int left=0,right=0,ans=0;
    int ln=fruits[left],rn=fruits[right];//两个篮子
    while(right<fruitsSize){
        if(fruits[right]==ln||fruits[right]==rn){
            ans=ans>(right-left+1)?ans:(right-left+1);
            right++;//找到相同的继续向右找
        }
        else {//将左蓝子移动到右篮子前一个，必定不相同，继续向前找
            left=right-1;
            ln=fruits[left];
            while(left>0&&fruits[left-1]==ln)left--;
            ans=ans>(right-left+1)?ans:(right-left+1);
            rn=fruits[right];
        }
    }
    return ans;
}
```



### 4.两个数组的交集(简单)

找出两个数组中相同的数并去重



```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 //排序加双指针
 int comp(void*a,void*b){
     return *(int*)a-*(int*)b;
 }
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    qsort(nums1,nums1Size,sizeof(int),comp);
    qsort(nums2,nums2Size,sizeof(int),comp);
    int a=0,b=0;
    int j=0;
    int *result=malloc(sizeof(int*)*(nums1Size+nums2Size));
    while(a<nums1Size&&b<nums2Size){
        if(nums1[a]>nums2[b])b++;
        else if(nums1[a]<nums2[b])a++;
        else {
            result[j++]=nums1[a];
            a++;
            b++;
            if(j>1&&result[j-1]==result[j-2])j--;//相等则下标后移，会覆盖。
        }
    }
    *returnSize=j;
    return result;
}
```



### 5.删除链表的倒数第N个结点(中等)

力扣19题

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。



```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

/*
双指针法，先让快指针走n步，然后快慢指针一起走。
*/
struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    struct ListNode*virtual=malloc(sizeof(struct ListNode));
    virtual->next=head;
    struct ListNode *low=virtual,*fast=virtual;
    while(n>0){
        fast=fast->next;
        n--;
    }
    while(fast->next){
        fast=fast->next;
        low=low->next;
    }
    fast=low->next;
    low->next=fast->next;
    free(fast);
    head=virtual->next;
    free(virtual);
    return head;
}
```





### 6.移动零(简单)







```
void moveZeroes(int* nums, int numsSize){
    int i=0,j=0;
    for(i=0;i<numsSize;++i){
        if(nums[i]!=0)nums[j++]=nums[i];
    }
    while(j<numsSize)nums[j++]=0;
}
```





### 7.反转数组(中等)

189

给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数



```
/*
    反转三次数组
*/
void reverse(int*nums,int a,int b){
    while(a<b){
        int t=nums[a];
        nums[a++]=nums[b];
        nums[b--]=t;
    }
}
void rotate(int* nums, int numsSize, int k){
    k%=numsSize;//数组周期变化，减少操作，还可以防止k大于数组数量
    reverse(nums,0,numsSize-1);
    reverse(nums,0,k-1);
    reverse(nums,k,numsSize-1);
}
```





### 7.最大连续1的个数

```
/*
    双指针
    每次都记录窗口内零的个数，保证窗口内零的个数小于移动次数，每次记录最大值
*/
int longestOnes(int* nums, int numsSize, int k){
    int ans=0;
    int zero=0;//记录零的个数
    int left=0,right=0;
    for(right=0;right<numsSize;++right){
        if(nums[right]==0)++zero;
        while(zero>k)if(nums[left++]==0)--zero;//移动左指针，让窗口内的零的个数小于移动次数
        ans=ans>(right-left+1)?ans:(right-left+1);
    }
    return ans;
}
```



### 8.考试的最大困扰度

原理看上题

```
/*
    双指针 滑动窗口
*/
int maxConsecutiveAnswers(char * answerKey, int k){
    int len=strlen(answerKey);
    int ans=0;
    int TF=0;
    int left=0,right=0;
    //改变T
    for(right=0;right<len;++right){
        if(answerKey[right]=='T')TF++;
        while(TF>k)if(answerKey[left++]=='T')--TF;
        ans=ans>(right-left+1)?ans:(right-left+1);
    }
    //改变F
    for(TF=0,left=0,right=0;right<len;++right){
        if(answerKey[right]=='F')TF++;
        while(TF>k)if(answerKey[left++]=='F')--TF;
        ans=ans>(right-left+1)?ans:(right-left+1);
    }
    return ans;
}
```



# 链表

### 设置链表(中等)

```c
//链表定义
typedef struct MyLinkedListTag{
    int val;
    struct MyLinkedListTag*next;
} MyLinkedList;

//链表创建
MyLinkedList* myLinkedListCreate() {
    MyLinkedList*head=malloc(sizeof(MyLinkedList));
    head->next=NULL;
    return head;
}
//获取链表下标值
int myLinkedListGet(MyLinkedList* obj, int index) {
    struct MyLinkedListTag*cur=obj->next;
    for(int i=0;cur;++i){
        if(i==index){
            return cur->val;
        }
        else cur=cur->next;
    }
    return -1;
}
//头插 
void myLinkedListAddAtHead(MyLinkedList* obj, int val) {
    struct MyLinkedListTag*newhead=malloc(sizeof(struct MyLinkedListTag));
    newhead->val=val;
    newhead->next=obj->next;
    obj->next=newhead;
}
//尾插
void myLinkedListAddAtTail(MyLinkedList* obj, int val) {
    struct MyLinkedListTag*cur=obj;
    while(cur->next){
        cur=cur->next;
    }
    struct MyLinkedListTag*p=malloc(sizeof(struct MyLinkedListTag));
    p->next=NULL;
    p->val=val;
    cur->next=p;
}
//插入
void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {
     //当idex小于0，直接调用头插
     if(index<=0){
         myLinkedListAddAtHead(obj,val);
         return;
     }
     //当0<idex<链表长度
     struct MyLinkedListTag*cur=obj->next;
     for(int i=1;cur;++i){
         if(i==index){
             struct MyLinkedListTag*temp=malloc(sizeof(struct MyLinkedListTag));
             temp->val=val;
             temp->next=cur->next;
             cur->next=temp;
             return;
         }
         else cur=cur->next;
     }
}
//删除
void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {
    if(index==0){
        struct MyLinkedListTag*temp=obj->next;
        if(temp){//验证是否存在
            obj->next=temp->next;
            free(temp);
        }
        return;
    }
    struct MyLinkedListTag*cur=obj->next;
    for(int i=1;cur&&cur->next;++i){
        if(i==index){
            struct MyLinkedListTag*temp=cur->next;
            if(temp){//验证下一个
                cur->next=temp->next;
                free(temp);
            }
            return;
        }
        else cur=cur->next;
    }
}

void myLinkedListFree(MyLinkedList* obj) {
    while(obj){
        struct MyLinkedListTag*temp=obj;
        obj=obj->next;
        free(temp);
    }
}

/**
 * Your MyLinkedList struct will be instantiated and called as such:
 * MyLinkedList* obj = myLinkedListCreate();
 * int param_1 = myLinkedListGet(obj, index);
 
 * myLinkedListAddAtHead(obj, val);
 
 * myLinkedListAddAtTail(obj, val);
 
 * myLinkedListAddAtIndex(obj, index, val);
 
 * myLinkedListDeleteAtIndex(obj, index);
 
 * myLinkedListFree(obj);
*/
```



















### 1.两数之和(中等)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/add-two-numbers

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

/*
    思路：链表相加，如果存在就相加，用carry记录进位，不存在就记为0.
*/
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    struct ListNode *head=NULL,*tail=NULL;//初始化返回链表
    int carry=0;
    while(l1||l2){
        int n1=l1?l1->val:0;
        int n2=l2?l2->val:0;
        int sum=n1+n2+carry;
        if(head==NULL){   //头节点不存在，初始化头节点
            head=tail=malloc(sizeof(struct ListNode));
            tail->val=sum%10;
            tail->next=NULL;
        }                  //用tail，方便返回头节点
        else {
            tail->next=malloc(sizeof(struct ListNode));
            tail->next->val=sum%10;
            tail=tail->next;
            tail->next=NULL;
        }
        carry=sum/10;
        if(l1)l1=l1->next;//让l1 l2往后走
        if(l2)l2=l2->next;
    }
    if(carry>0){  //如果大于0，创键新的结点来存放
        tail->next=malloc(sizeof(struct ListNode));
        tail->next->val=carry;
        tail->next->next=NULL;
    }
    return head;
}
```



### 2.移除链表元素(简单)



给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。


示例 1：


输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-linked-list-elements
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



思路：设置虚拟头节点，方便操作

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeElements(struct ListNode* head, int val){
    struct ListNode*pre=malloc(sizeof(struct ListNode));
    pre->val=0;
    pre->next=head;
    struct ListNode*cur=pre;
    while(cur->next){
        if(cur->next->val==val){
            struct ListNode*temp=cur->next;
            cur->next=temp->next;
            free(temp);
        }
        else cur=cur->next;
    }
    head=pre->next;//？？？有什么用？？
    free(pre);
    return head;
}
```





### 3.链表相交(简单)



给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。





```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode*a=headA;
    struct ListNode*b=headB;
    while(a!=b){
        a = (a==NULL?headB:a->next);
        b = (b==NULL?headA:b->next);
    }
    return a;
}
```



### 4.环形链表Ⅱ(中等)

142





这个题感觉用到了数学归纳法

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。



```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 /*难点：如何找到环的入口
    找到相遇节点时，让慢指针回到头节点，都一次走一步，相遇即为节点
 */
struct ListNode *detectCycle(struct ListNode *head) {
    if(!head)return NULL;

    //快慢指针
    struct ListNode*low=head,*fast=head;
    while(fast&&fast->next){
        fast=fast->next->next;
        low=low->next;
        //找入口
        if(fast==low){
            low=head;
            while(fast!=low){
                fast=fast->next;
                low=low->next;
            }
            return fast;
        }
    }
    return NULL;
}
```





### 5.用栈(链表)实现队列(simple)



```
/*
    链表实现
*/
typedef struct Queue{
    int val;
    struct Queue *next;
} MyQueue;

//创建队列
MyQueue* myQueueCreate() {
    MyQueue *L=(MyQueue*)malloc(sizeof(struct Queue));
    L->next=NULL;
    L->val=0;
    return L;
}
//压入元素
void myQueuePush(MyQueue* obj, int x) {
    //链表创建新结点，头插法
    struct Queue *t=obj->next;
    struct Queue *a=(MyQueue*)malloc(sizeof(struct Queue));
    a->val=x;
    a->next=t;
    obj->next=a;
}
//返回队头元素
int myQueuePop(MyQueue* obj) {//先进先出，返回第一个进的即头插法中最后一个
        struct Queue *t=obj->next,*pre=obj;
        while(t->next){
            pre=pre->next;
            t=t->next;
        }
        pre->next=NULL;
        int a=t->val;
        free(t);
        return a;
}
//弹出队列头元素
int myQueuePeek(MyQueue* obj) {
        struct Queue *t=obj->next;
        while(t->next)t=t->next;
        return t->val; 
}
//判断是否为空
bool myQueueEmpty(MyQueue* obj) {
    if(obj->next)return false;//存在队列满
    return true;
}
//释放队列
void myQueueFree(MyQueue* obj) {
    while(obj){
        struct Queue *t=obj;
        obj=obj->next;
        free(t);
    }
}

/**
 * Your MyQueue struct will be instantiated and called as such:
 * MyQueue* obj = myQueueCreate();
 * myQueuePush(obj, x);
 
 * int param_2 = myQueuePop(obj);
 
 * int param_3 = myQueuePeek(obj);
 
 * bool param_4 = myQueueEmpty(obj);
 
 * myQueueFree(obj);
*/
```





### 6.将两个链表合并成一个链表(PTA) (Bug满天飞😅)为什么PTA能过，编译器过不了？？



输入两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。

在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出`NULL`。

```in
1 3 5 -1
2 4 6 8 10 -1
```

```out
1 2 3 4 5 6 8 10
```





```
#include<stdio.h>
#include<stdlib.h>
typedef struct List{
    int val;
    struct List *next;
}*LNode;
//创造链表
struct List* creative(void){
    LNode L=(LNode)malloc(sizeof(struct List));
    LNode t=L;
    L->next=NULL;
    L->val=0;
    int e;
    scanf("%d",&e);
    while(e!=-1){
        LNode temp=(LNode)malloc(sizeof(struct List));
        temp->next=NULL;
        temp->val=e;
        t->next=temp;
        t=temp;
        scanf("%d",&e);
    }
    return L->next;
}
//插入
void insert(LNode L,int e){
	LNode t=L;
	while(t->next){
		t=t->next;
	} 
	LNode temp=(LNode)malloc(sizeof(struct List));
	temp->val=e;
	temp->next=NULL;
	t->next=temp;
} 
//打印
void print(LNode L){
	LNode t=L->next;
    if(!t){
        printf("NULL");
        return ;
    }
	while(t){
        if(t->next)
		printf("%d ",t->val);
        else
            printf("%d",t->val);
		t=t->next;
	}
    printf("\n");
} 
int main()
{
    LNode L1,L2;
    L1=creative();
    L2=creative();
    LNode new=(LNode)malloc(sizeof(struct List));
    while(L1&&L2){
    	if(L1->val<L2->val){
    		insert(new,L1->val);
    		L1=L1->next;
		}
		else{
			insert(new,L2->val);
			L2=L2->next;
		}
	}
	LNode t=new;
	while(t->next)t=t->next;
	if(L2)t->next=L2;
	if(L1)t->next=L1; 
	print(new);
    return 0;
}
```





### 7.删除链表中的结点(简单)

只给一个结点，删除这个结点

```
void deleteNode(struct ListNode* node) {
    struct ListNode *t=node->next;
    while(t->next){
        node->val=t->val;
        node=node->next;
        t=t->next;
    }
    node->val=t->val;
    node->next=NULL;
}
```











**important：while循环内条件，有先后循序，让小的在前，判断完直接返回，防止出现空指针**









# 树

### 1.二叉树的中序遍历(简单)

递归实现(√)

迭代实现

morris实现

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 
void inordertree(struct TreeNode *root,int *res, int *reSize)
 {
     if(root==NULL)return;
     inordertree(root->left,res,reSize);
     res[(*reSize)++] = root->val;
     inordertree(root->right,res,reSize);
 }
int* inorderTraversal(struct TreeNode* root, int* returnSize){
    *returnSize=0;
    int *res=malloc(sizeof(int*)*500);
    inordertree(root,res,returnSize);
    return res;

}
```



### 2.二叉树的最大深度(简单)



给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。





```
int maxDepth(struct TreeNode* root){
    if(root){
        int l=maxDepth(root->left)+1;
        int r=maxDepth(root->right)+1;
        int max=l>r?l:r;
        return max;
    }
    return 0;
}
```



### 3.二叉树的层序遍历



102



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    *returnColumnSizes=(int*)malloc(sizeof(int)*2000);
    int **result=(int**)malloc(sizeof(int*)*2000);
    *returnSize=0;
    if(!root)return result;
    //开辟指针结构体数组
    struct TreeNode *queue[2000];
    //先将根节点放入队列
    int l=0,r=0;
    queue[r++]=root;
    while(l<r){
        int cnt=0;//记录每层的数
        int temp=r;//记录当前层数由多少个数
        result[*returnSize]=(int*)malloc(sizeof(int)*1000);
        while(l<temp){
            if(queue[l]->left)queue[r++]=queue[l]->left;
            if(queue[l]->right)queue[r++]=queue[l]->right;
            result[*returnSize][cnt++]=queue[l++]->val;
        }
        (*returnColumnSizes)[(*returnSize)++]=cnt;
    }
    return result;
}
```

### 4.二叉树的层序遍历Ⅱ



107



给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

 



对层序遍历数组进行反转

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
 //层序遍历加反转
 #define max 2001
int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    int **result=(int**)malloc(sizeof(int*)*max);
    *returnColumnSizes=(int*)malloc(sizeof(int)*max);
    *returnSize=0;
    if(!root)return result;
    struct TreeNode *queue[max];
    int l=0,r=0;
    queue[r++]=root;
    while(l<r){
        int cnt=0;
        int temp=r;
        result[*returnSize]=(int*)malloc(sizeof(int)*max);
        while(l<temp){
            if(queue[l]->left)queue[r++]=queue[l]->left;
            if(queue[l]->right)queue[r++]=queue[l]->right;
            result[(*returnSize)][cnt++]=queue[l++]->val;
        }
        (*returnColumnSizes)[(*returnSize)++]=cnt;
    }
    struct TreeNode *a;
    int b;
    for(int i=0,j=(*returnSize)-1;i<j;++i,--j){
        a=result[i];
        result[i]=result[j];
        result[j]=a;
        b=(*returnColumnSizes)[i];
        (*returnColumnSizes)[i]=(*returnColumnSizes)[j];
        (*returnColumnSizes)[j]=b;
    }
    return result;
}
```

### 5.二叉树的右视图



199



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 //层序遍历，每次都记录最后一个数
int* rightSideView(struct TreeNode* root, int* returnSize){
    //建立队列
    struct TreeNode *q[10000];
    //返回数组
    int *result=(int*)malloc(sizeof(int)*100);

    *returnSize=0;
    if(!root)return result;
    int l=0,r=0;
    q[r++]=root;
    result[(*returnSize)]=root->val;
    while(l<r){
        int temp=r;
        while(l<temp){
            if(q[l]->left)q[r++]=q[l]->left;
            if(q[l]->right)q[r++]=q[l]->right;
            l++;
        }
        //for(int i=l;i<r;++i)printf("%d ",q[i]->val);
        result[++(*returnSize)]=q[r-1]->val;
    }
    return result;
}
```



### 6.二叉树的层平均值(简单)

637



给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
double* averageOfLevels(struct TreeNode* root, int* returnSize){
    struct TreeNode*q[10000];
    *returnSize=0;
    double *result=(double*)malloc(sizeof(double)*1001);
    int l=0,r=0;
    q[r++]=root;
    while(l<r){
        double sum=0;
        int cnt=0;
        int temp=r;
        while(l<temp){
            sum+=q[l]->val;
            cnt++;
            if(q[l]->left)q[r++]=q[l]->left;
            if(q[l]->right)q[r++]=q[l]->right;
            l++;
        }
        result[(*returnSize)++]=sum/cnt;
    }
    return result;
}
```

### 7. N叉树的层序遍历

429



```
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     int numChildren;
 *     struct Node** children;
 * };
 */

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
 
int** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes) {
    *returnSize=0;
    *returnColumnSizes=(int**)malloc(sizeof(int*)*1000);
    int **result=(int**)malloc(sizeof(int*)*1000);
    if(!root)return result;
    
    struct Node*q[10000];
    int l=0,r=0;
    q[r++]=root;
    while(l<r){
        int temp=r;
        int ColSize=0;//记录每层由多少数
        result[*returnSize]=(int*)malloc(sizeof(int)*(r-l+1));

        while(l<temp){ 
            result[(*returnSize)][ColSize++]=q[l]->val;//记录当前数的值
            if(q[l]->numChildren){   
                for(int i=0;i<q[l]->numChildren;++i)q[r++]=q[l]->children[i];
            }
            l++;
        }

        (*returnColumnSizes)[(*returnSize)++]=ColSize;
    }
    return result;
}
```



### 8.在每个树行中找最大值

515

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* largestValues(struct TreeNode* root, int* returnSize){
    int *result=(int*)malloc(sizeof(int)*10000);
    *returnSize=0;
    if(!root)return result;
    struct TreeNode*q[10000];
    int l=0,r=0;
    q[r++]=root;
    while(l<r){
        int temp=r;
        int max=q[l]->val;
        while(l<temp){
            if(q[l]->val>max)max=q[l]->val;
            if(q[l]->left)q[r++]=q[l]->left;
            if(q[l]->right)q[r++]=q[l]->right;
            l++;
        }
        result[(*returnSize)++]=max;
    }
    return result;
}
```



### 9.填充每一个结点的下一个右侧指针



116

```
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     struct Node *left;
 *     struct Node *right;
 *     struct Node *next;
 * };
 */

struct Node* connect(struct Node* root) {
	if(!root)return root;
    struct Node *q[10000];
    int l=0,r=0;
    q[r++]=root;
    while(l<r){
        int tem=l;
        int temp=r;
        while(l<temp){
            if(q[l]->left)q[r++]=q[l]->left;
            if(q[l]->right)q[r++]=q[l]->right;
            l++;
        }
        for(int i=tem;i<(temp-1);++i)q[i]->next=q[i+1];
    }
    return root;
}
```



other

不开辟新空间

空间复杂度 O(1)

```
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     struct Node *left;
 *     struct Node *right;
 *     struct Node *next;
 * };
 */
//每次依据上层的next位置已经知道
struct Node* connect(struct Node* root) {
	if(!root)return root;
    struct Node*pre=root;
    while(pre->left){
        struct Node *temp=pre;
        while(temp){
            temp->left->next=temp->right;//连接父母节点下的左右
            if(temp->next)temp->right->next=temp->next->left;//连接亲戚间的结点
            temp=temp->next;
        }
        pre=pre->left;
    }
    return root;
}
```



### 10.翻转二叉树



226



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

struct TreeNode* invertTree(struct TreeNode* root){
    if(root==NULL)return NULL;
    //将左右结点交换
    struct TreeNode *t=root->left;
    root->left=root->right;
    root->right=t;
    //继续交换后续结点
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```



### 11.对称二叉树



111



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
bool compare(struct TreeNode *left,struct TreeNode *right){
    //都为空
    if(left==NULL&&right==NULL)
        return true;
    //有一个为空
    if(left==NULL||right==NULL)
        return false;
    //值不相等
    if(left->val!=right->val)
        return false;
    //值都存在进行比较
    return compare(left->left,right->right)&&compare(left->right,right->left);
}

bool isSymmetric(struct TreeNode* root){
    if(!root)return true;
    return compare(root->left,root->right);
}

```



### 12.完全二叉树的节点个数



222



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
//层序遍历

int countNodes(struct TreeNode* root){
    if(!root)return 0;
    struct TreeNode*q[60000];
    int l=0,r=0;
    int cnt=1;
    q[r++]=root;
    while(l<r){
        int temp=r;
        while(l<temp){
            if(q[l]->left)
            {
                q[r++]=q[l]->left;
                cnt++;
            }
            if(q[l]->right)
            {
                q[r++]=q[l]->right;
                cnt++;
            }
            l++;
        }
    }
    return cnt;
}
```



```
//递归dfs

int countNodes(struct TreeNode* root){
    if(!root)return 0;
    else return countNodes(root->left)+countNodes(root->right)+1;
}
```

### 13.平衡二叉树

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
 //求左右树高度，如果大于 1 就返回 -1
int dfs(struct TreeNode *root)
{
    if(!root)return 0;
    int l=dfs(root->left);
    if(l==-1)return -1;
    int r=dfs(root->right);
    if(r==-1)return -1;
    if(abs(l-r)>1)return -1;
    else return fmax(l,r)+1;
}

bool isBalanced(struct TreeNode* root){
    return dfs(root)!=-1;
}
```



### 14.二叉树的所有路径(回溯)





```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

char ** binaryTreePaths(struct TreeNode* root, int* returnSize){
    
    char **result=(char**)malloc(sizeof(char*)*1000);
    *returnSize=0;
    int ans[1024];//存放数
    paths(root,result,returnSize,ans,0);
    return result;
}
void paths(struct TreeNode *root,char**result,int *returnSize,int *ans,int local){
    if(!root)return ;
    if(!root->left&&!root->right){
        int len=0;
        char *t=(char*)malloc(sizeof(char)*1001);
        for(int i=0;i<local;++i){
            len+=sprintf(len+t,"%d->",ans[i]);
        }
        sprintf(t+len,"%d",root->val);
        result[(*returnSize)++]=t;
    }
    else {
        ans[local++]=root->val;
        if(root->left)paths(root->left,result,returnSize,ans,local);
        if(root->right)paths(root->right,result,returnSize,ans,local);
    }
}
```



### 15.找树左下角的值





层序遍历，每次都记录第一个值即为最左边的值

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

//层序遍历
int findBottomLeftValue(struct TreeNode* root){
    struct TreeNode*q[10001];
    int l=0,r=0;
    q[r++]=root;
    int ans=0;
    while(l<r){
        int temp=r;
        ans=q[l]->val;
        while(l<temp){
            if(q[l]->left)q[r++]=q[l]->left;
            if(q[l]->right)q[r++]=q[l]->right;
            l++;
        }
    }
    return ans;
}
```



### 16.路径总和



找一条路径上的总和等于给定的数







```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

//回溯问题
bool tb(struct TreeNode*root,int count){
    //终止条件
    if(!root->left&&!root->right&&count==0)return true;
    else {
        if(root->left){
            if(tb(root->left,count-root->left->val))return true;
        }
        if(root->right){
            if(tb(root->right,count-root->right->val))return true;
        }
    }
    return false;
}
bool hasPathSum(struct TreeNode* root, int targetSum){
    if(!root)return false;
    int count=targetSum;
    return tb(root,count-root->val);
}
```



### 17.中序遍历和后序遍历构造二叉树



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

/*
    递归切割中序数组和后序数组
    难点在于如何切割，边界问题
*/
struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){
    //如果根节点为空或者为叶子节点
    if(inorder==0||postorderSize==0)return NULL;
    //后序遍历最后一个为亲节点
    struct TreeNode *root=(struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val=postorder[postorderSize-1];
    //从前序遍历中找到亲节点的值，进行分割
    int left;
    for(left=0;left<inorderSize;++left)if(inorder[left]==root->val)break;
    
    int right=postorderSize-left-1;//右子树的节点个数，left为左子树的节点个数

    root->left=buildTree(inorder,left,postorder,left);
    root->right=buildTree(inorder+left+1,right,postorder+left,right);
    return root;
}
```



### 18.前序和中序构造二叉树



![image-20220419161401602](C:\Users\boy\AppData\Roaming\Typora\typora-user-images\image-20220419161401602.png)





```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize){
    if(preorderSize==0||inorderSize==0)return NULL;
    struct TreeNode*root=(struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val=preorder[0];
    int left;
    for(left=0;left<inorderSize;++left)if(inorder[left]==root->val)break;
    int right=inorderSize-left-1;
    root->left=buildTree(preorder+1,left,inorder,left);
    root->right=buildTree(preorder+left+1,right,inorder+left+1,right);
    return root;
}
```



### 19.最大二叉树

给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

创建一个根节点，其值为 nums 中的最大值。
递归地在最大值 左边 的 子数组前缀上 构建左子树。
递归地在最大值 右边 的 子数组后缀上 构建右子树。
返回 nums 构建的 最大二叉树 。

 

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-binary-tree







```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize){
    if(numsSize==0)return NULL;
    int maxi=0,max=0;
    for(int i=0;i<numsSize;++i)if(nums[i]>max){max=nums[i];maxi=i;}
    struct TreeNode *root=(struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val=max;
    root->left=constructMaximumBinaryTree(nums,maxi);
    root->right=constructMaximumBinaryTree(nums+maxi+1,numsSize-maxi-1);
    return root;
}
```



### 20.合并两个二叉树



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

//直接在原树上进行修改
struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){
    if(!root1)return root2;
    if(!root2)return root1;
    root1->val+=root2->val;
    root1->left=mergeTrees(root1->left,root2->left);
    root1->right=mergeTrees(root1->right,root2->right);
    return root1;
}
```





### 21.二叉搜索树中的搜索





迭代

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* searchBST(struct TreeNode* root, int val){
    while(root){
        if(root->val>val)root=root->left;
        else if(root->val<val) root=root->right;
        else return root;
    }
    return NULL;
}
```



递归



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* searchBST(struct TreeNode* root, int val){
    if(root==NULL||root->val==val)return root;
    else if(root->val>val)return searchBST(root->left,val);
    else if(root->val<val)return searchBST(root->right,val);
    return NULL;
}
```



### 22.验证二叉搜索树（boom）



```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
void traver(struct TreeNode*root,int *a,int *i){
    if(root){
        traver(root->left,a,i);//此时 i 已经是指针，传入的时候直接传 i 就好
        a[(*i)++]=root->val;
        traver(root->right,a,i);
    }
}
bool isValidBST(struct TreeNode* root){
    int a[10001];
    int i=0;
    traver(root,a,&i);
    //for(int j=0;j<i;++j)printf("%d ",a[j]);
    for(int j=0;j<i-1;++j)if(a[j]>=a[j+1])return false;
    return true;
}
```



### 23.二叉搜索树的最小绝对差





```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
void traverse(struct TreeNode*root,int *a,int *i){
    if(!root)return ;
    traverse(root->left,a,i);
    a[(*i)++]=root->val;
    traverse(root->right,a,i);
}

int getMinimumDifference(struct TreeNode* root){
    if(!root)return ;
    int a[10001];
    int i=0;
    traverse(root,a,&i);
    int min=INT_MAX;
    for(int j=1;j<i;++j){
        if(abs(a[j]-a[j-1])<min)min=abs(a[j]-a[j-1]);
    }
    return min;
}
```



### 24.二叉搜索树的众数





```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    int count=0,maxcount=0;
    struct TreeNode*pre=NULL;
    vector<int>result;
    void traverse(struct TreeNode*root){
        if(!root)return ;
        traverse(root->left);//左

        //对数据的处理
        //判断与前一个数的关系
        if(pre==NULL)count=1;
        else if(pre->val==root->val)count++;
        else count=1;
        pre=root;

        //判断该数出现的次数
        if(maxcount==count){
            result.push_back(root->val);
        }
        else if(maxcount<count){
            maxcount=count;
            result.clear();
            result.push_back(root->val);
        }

        traverse(root->right);//右
    }
public:
    vector<int> findMode(TreeNode* root) {
        traverse(root);
        return result;
    }
};
```







### 25.二叉树的最近公共祖先



给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

 

示例 1：

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
示例 2：


输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
示例 3：

输入：root = [1,2], p = 1, q = 2
输出：1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。





```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 /*
    1.如果该节点等于p 或q 或者为空 直接返回
    2.如果左右节点都存在返回祖先节点
    3.递归左右节点，返回存在的那个节点
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root||p==root||q==root)return root;
        TreeNode *left=lowestCommonAncestor(root->left,p,q);
        TreeNode *right=lowestCommonAncestor(root->right,p,q);
        if(left&&right)return root;
        return left==NULL?right:left;
    }
};
```



### 26.二叉搜索树的插入



```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(!root){
            TreeNode*t=new TreeNode(val);
            return t;
        }
        if(root->val<val)root->right = insertIntoBST(root->right,val);
        if(root->val>val)root->left=insertIntoBST(root->left,val);
        return root;
    }
};
```



### 27.二叉搜索树的删除



```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 /*
    五种情况
    1.根节点不存在
    2.删除节点的左右孩子为空 直接删除
    3.删除孩子的左节点为空，右节点补位
    4.删除孩子的右节点为空，左节点补位
    5。左右节点都存在，将左节点放到右节点的最左边
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root)return root;
        if(root->val==key){
            if(!root->left&&!root->right)
            {
                delete root;
                return NULL;
            }
            else if(!root->left&&root->right)return root->right;
            else if(root->left&&!root->right)return root->left;
            else 
            {
                TreeNode*cur=root->right;
                TreeNode*t=root->right;
                while(t->left)t=t->left;
                t->left=root->left;
                delete root;
                return cur;
            }
        }
        if(root->val>key)root->left=deleteNode(root->left,key);
        if(root->val<key)root->right=deleteNode(root->right,key);
        return root;
    }
};

```



### 28.树的子结构

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 /*
    先对根节点进行判断
    然后将A的子树与B进行判断
    判断函数 B空true
            值不相等false
            在进行左右子树判断
 */
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        return (A!=NULL&&B!=NULL)&&(boolis(A,B)||isSubStructure(A->left,B)||isSubStructure(A->right,B));
    }
    bool boolis(struct TreeNode *A,struct TreeNode *B){
        if(B==NULL)return true;
        if(A==NULL||A->val!=B->val)return false;
        return boolis(A->left,B->left)&&boolis(A->right,B->right);
    }
};
```



```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSubStructure(A *TreeNode, B *TreeNode) bool {
    return (A!=nil && B!=nil)&&(boolis(A,B)||isSubStructure(A.Left,B)||isSubStructure(A.Right,B))
}
func boolis (A *TreeNode , B *TreeNode) bool {
    if B == nil {
        return true
    }
    if A == nil || A.Val!=B.Val {
        return false
    }
    return boolis(A.Left,B.Left) && boolis(A.Right,B.Right)
}
```



### 29.二叉搜索树转换为累加树



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 /*
    顺序：右 中 左
 */
class Solution {
    private:
    int pre=0;
    void sumbin(TreeNode *root){
        if(!root)return ;
        sumbin(root->right);
        pre+=root->val;
        root->val=pre;
        sumbin(root->left);
    }
public:
    TreeNode* convertBST(TreeNode* root) {
        sumbin(root);
        return root;
    }
};
```





# 回溯

### 1.全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/permutations
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。







```
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> re;
        vector<int> use(nums.size(),0);
        def(res,re,use,nums);
        return res;
    }
    void def(vector<vector<int>>&res,vector<int>&re,vector<int>&use,vector<int> &nums){
        if(re.size()==nums.size()){
            res.push_back(re);
            return ;
        }
        else {
            for(int i=0;i<nums.size();++i){
                if(use[i]==0){
                    re.push_back(nums[i]);
                    use[i]=1;
                    def(res,re,use,nums);
                    use[i]=0;
                    re.pop_back();
                }
            }
        }
    }
};
```



### 2.组合

给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 任何顺序 返回答案。

 

示例 1：

输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/combinations
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



```c++
class Solution {
    private:
    vector<vector<int> >result;
    vector<int> path;
    void backtracking(int n,int k,int startindex){
        if(path.size()==k){
            result.push_back(path);
        }
        else {
            for(int i=startindex;i<=n;++i){
                path.push_back(i);
                backtracking(n,k,i+1);
                path.pop_back();
            }
        }
        return;
    }
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }
};
```

剪枝

![image-20220517223525070](C:\Users\boy\AppData\Roaming\Typora\typora-user-images\image-20220517223525070.png)





![image-20220517223550056](C:\Users\boy\AppData\Roaming\Typora\typora-user-images\image-20220517223550056.png)





```
class Solution {
    private:
    vector<vector<int> >result;
    vector<int> path;
    void backtracking(int n,int k,int startindex){
        if(path.size()==k){
            result.push_back(path);
        }
        else {
            for(int i=startindex;i<=n-(k-path.size())+1;++i){

                path.push_back(i);
                backtracking(n,k,i+1);
                path.pop_back();
            }
        }
        return;
    }
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }
};
```





### 3.组合





```
class Solution {
    private:
    vector<vector<int> >ans;
    vector<int>path;
    void comb(int k,int n,int sum,int idexs){
        if(sum>n)return ;
        if(path.size()==k&&sum==n){
            ans.push_back(path);
        }
        else {
            for(int i=idexs;i<=9;++i){
                sum+=i;
                path.push_back(i);
                comb(k,n,sum,i+1);
                path.pop_back();
                sum-=i;
            }
        }
    }
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        comb(k,n,0,1);
        return ans;
    }
};
```



### 4.电话号码组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)









```
class Solution {
    private:
    const string numbermap[10]{
        "",//0
        "",//1
        "abc",//2
        "def",//3
        "ghi",//4
        "jkl",//5
        "mno",//6
        "pqrs",//7
        "tuv",//8
        "wxyz",//9
    };
public:
    vector<string>result;
    string s;
    void bin(const string &digits,int idex){
        //结束条件
        if(digits.size()==idex){
            result.push_back(s);
            return ;
        }

        int digit=digits[idex]-'0';
        string letter=numbermap[digit];

        for(int i=0;i<letter.size();i++){
            s.push_back(letter[i]);

            bin(digits,idex+1);

            s.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.size()==0){
            return result;
        }
        bin(digits,0);
        return result;
    }
};
```

### 5.组合总数



给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

 

示例 1：

输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/combination-sum



```
class Solution {
public:
    vector<vector<int> >result;
    vector<int>path;
    void tb(vector<int>&candidates,int target,int sum,int s){
        if(sum>target)return;
        if(sum==target){
            result.push_back(path);
            return;
        }
        for(int i=s;i<candidates.size();++i){
            path.push_back(candidates[i]);
            tb(candidates,target,sum+candidates[i],i);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        tb(candidates,target,0,0);
        return result;
    }
};
```

### 6.组合总数



给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用 一次 。

注意：解集不能包含重复的组合。 

 

示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/combination-sum-ii

```c++
class Solution {
private:
    vector<vector<int> > re;
    vector<int> path;
    void backtrack(vector<int>& candidates,int start,int target,int sum)
    {
        if(sum>target)return;
        if(sum==target)
        {
            re.push_back(path);
            return;
        }
        else
        {
            for(int i=start;i<candidates.size();++i)
            {
                if(i>start&&candidates[i]==candidates[i-1])continue;//精髓
                path.push_back(candidates[i]);
                sum+=candidates[i];
                backtrack(candidates,i+1,target,sum);
                path.pop_back();
                sum-=candidates[i];
            }
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        backtrack(candidates,0,target,0);
        return re;
    }
};
```

### 7.每个树行中找最大值

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    private:
    vector<int>s;
public:
    void dfs(TreeNode *root , int a)
    {
        if(!root)return ;
        if(s.size()==a)s.emplace_back(root->val);//第一次遇见直接放入容易
        else s[a]=s[a]>root->val?s[a]:root->val;//再次相同层时，记录最大值
        if(root->left)dfs(root->left,a+1);
        if(root->right)dfs(root->right,a+1);
        
    }
    vector<int> largestValues(TreeNode* root) {
        dfs(root,0);
        return s;
    }
};
```



### 8.分割回文串



给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

 

```c++
class Solution {
    private:
    vector<vector<string> >res;
    vector<string>path;
public:
    void trackblack(string &s,int start)
    {
        if(start>=s.size())
        {
            res.push_back(path);
            return ;
        }
        for(int i=start;i<s.size();++i)
        {
            if(islegal(s,start,i))//如果是回文字符串，就放入
            {
                string str=s.substr(start,i-start+1);
                path.push_back(str);
            }
            else 
            {
                continue;//如果不是回文字符串就往后找 例如 ab不是 往后找aba
            }
            trackblack(s,i+1);//继续从除了放入字符串之外的字符串
            path.pop_back();//回溯过程
        }
    }
    bool islegal(string &s,int l,int r)//判断是否为会问字符串
    {
        while(l<r)
        {
            if(s[l]==s[r])
            {
                l++;
                r--;
            }
            else return false;
        }
        return true;
    }
    vector<vector<string>> partition(string s) {
        trackblack(s,0);
        return res;
    }
};
```



### 9.N皇后



```
class Solution {
private:
    vector<vector<string> > result;
    
public:
    void backtrack(int n,int row,vector<string> &path)
    {
        if(row==n)
        {
            result.push_back(path);
            return ;
        }
        for(int col=0;col<n;col++)
        {
            if(IsEmpty(path,row,col,n))//如果能够放下皇后就继续回溯，不然寻找下一个位置
            {
                path[row][col]='Q';
                backtrack(n,row+1,path);
                path[row][col]='.';
            }
        }
    }
    bool IsEmpty(vector<string> &path,int row,int col,int n)
    {
        for(int i=0;i<row;++i)//检查90
        {
            if(path[i][col]=='Q')return false;
        }
        for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--)//135
        {
            if(path[i][j]=='Q')return false;
        }
        for(int i=row-1,j=col+1;i>=0&&j<n;i--,j++)//45
        {
            if(path[i][j]=='Q')return false;
        }
        return true;
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string> path(n,string(n,'.'));
        backtrack(n,0,path);
        return result;
    }
};
```



### 10.复原IP

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/restore-ip-addresses






```
class Solution {
private:
    vector<string> result;
public:
    void backtrack(string &s,int start,int point)
    {
        if(point==3)//point记录逗号数量，如果是3证明分为三段
        {
            if(isvalid(s,start,s.size()-1))//判断第四段字符是否符合
            {
                result.push_back(s);
            }
            return;
        }
        for(int i=start;i<s.size();++i)
        {
            //先判断这个子串是否合法、
            if(isvalid(s,start,i))
            {
                //合法就回溯
                s.insert(s.begin()+i+1,'.');//在i的后面插入以一个.
                backtrack(s,i+2,point+1);
                s.erase(s.begin()+i+1);
            }
            else break;
        }
    }
    //判断字符串 [start ， end]是否合法
    bool isvalid(string &s,int start,int end)
    {
        if(start>end)return false;
        if(s[start]=='0'&&start!=end)return false;//前导0
        int m=0;
        for(int i=start;i<=end;++i)
        {
            if(s[i]<'0'||s[i]>'9')return false;
            m=m*10+(s[i]-'0');
            if(m>255)return false;
        }
        return true;
    }
    vector<string> restoreIpAddresses(string s) {
        backtrack(s,0,0);
        return result;
    }
};
```









### 11.子集Ⅱ



![image-20220708164002157](C:\Users\boy\AppData\Roaming\Typora\typora-user-images\image-20220708164002157.png)

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/subsets-ii

```c++
class Solution {
    vector<vector<int >> result;
    vector<int> path;
public:
    void backtrack(vector<int>&nums,int start ,vector<bool>&isvalid)
    {
        result.push_back(path);
        for(int i=start;i<nums.size();++i)
        {
            //isvalid[i-1]==true说明nums[i-1]该树枝已经使用过
            //isvalid[i-1]==false说明nums[i-1]该层已经使用过
            if(i>0&&nums[i]==nums[i-1]&&isvalid[i-1]==false)continue ;
            path.push_back(nums[i]);
            isvalid[i]=true;
            backtrack(nums,i+1,isvalid);
            isvalid[i]=false;
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<bool>isvalid(nums.size(),false);
        sort(nums.begin(),nums.end());
        backtrack(nums,0,isvalid);
        return result;
    }
};
```

### 12.递增子序列



给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/increasing-subsequences





```c++
set 去重
set::find(elemt);
该功能检查元素是否属于集合。 如果元素属于集合，则它返回确切的迭代器位置，否则返回set.end() 。
```





```
class Solution {
    vector<vector<int> > result;
    vector<int>path;
public:
    void back(vector<int> &nums,int start)
    {
        if(path.size()>1)result.push_back(path);
        //每一层都开一个set去重
        unordered_set<int> use;
        for(int i=start;i<nums.size();++i)
        {
            //同一层元素不能重复
            if(!path.empty()&&nums[i]<path.back()||use.find(nums[i])!=use.end())continue;
            path.push_back(nums[i]);
            use.insert(nums[i]);//记录该元素本层使用过
            back(nums,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        back(nums,0);
        return result;
    }
};
```



### 13.全排列Ⅱ

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

 

示例 1：

输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/permutations-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

![image-20220714220156651](C:\Users\boy\AppData\Roaming\Typora\typora-user-images\image-20220714220156651.png)



[1,12]该数组选取第一个开头和选取第二个开头，排列是一样的，

1	1	2

​	  2	 1

1	2	 1

​	  1	 2

一个父节点的一层不能重复。

为什么use[i-1]==false ?

因为同一层use[i-1]才为false





```c++
class Solution {
private:
    vector<vector<int> > result;
    vector<int> path;
public:
    void back(vector<int> &nums,int num,vector<bool> &use)
    {
        if(path.size()>=nums.size())
        {
            result.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();++i)
        {
            //use[i]==true是从该数组中选出来的数不能重复
            //i>0&&nums[i]==nums[i-1]&&use[i-1]==false是该树根的这一层不能重复，
            if(use[i]==true||i>0&&nums[i]==nums[i-1]&&use[i-1]==true)continue;
            use[i]=true;
            path.push_back(nums[i]);
            back(nums,i+1,use);
            use[i]=false;
            path.pop_back();
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(),nums.end());
        vector<bool> use(nums.size(),false);
        back(nums,0,use);
        return result;
    }
};
```









# 二分

### 1.吃香蕉的珂珂



珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。

珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。

 

示例 1：

输入：piles = [3,6,7,11], h = 8
输出：4



```
class Solution {
    //二分 先找出最大值，逐渐二分
private:
    //计算全部吃完需要的时间
    int check(vector<int>&piles,int k){
        int ans=0;
        for(int i=0;i<piles.size();++i){
            ans+=piles[i]/k;
            if(piles[i]%k)ans++;
        };
        return ans;
    }

public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int max=-1;
        for(int i=0;i<piles.size();++i)max=max<piles[i]?piles[i]:max;
        int l=1,r=max;
        int mid=-1;
        while(l<r){
            mid=l+(r-l)/2;
            //能全部吃完，寻找更慢的
            if(check(piles,mid)<=h)r=mid;
            else l=mid+1;
        }
        return r;
    }
};
```





# 动态规划



### 1.旋转函数(中等)

给定一个长度为 n 的整数数组 nums 。

假设 arrk 是数组 nums 顺时针旋转 k 个位置后的数组，我们定义 nums 的 旋转函数  F 为：

F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]
返回 F(0), F(1), ..., F(n-1)中的最大值 。

生成的测试用例让答案符合 32 位 整数。

 

示例 1:

输入: nums = [4,3,2,6]
输出: 26
解释:
F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/rotate-function





动态规划类题目一定要画图，亲自推导公式



```
/*
    dp
    公式： F(n) = F(n-1) + sum - numsSize*f(numsSize - n)
*/



int maxRotateFunction(int* nums, int numsSize){
    double max=0,sum=0;
    for(int i=0;i<numsSize;++i){
        sum+=nums[i];
        max+=i*nums[i];
    }
    double ans=max;
    for(int i=1;i<numsSize;++i){
    	//公式
        double cur=max+sum-numsSize*nums[numsSize-i];
        max=cur;
        if(cur>ans)ans=cur;
    }
    return  ans;
}
```



找规律过程

![e4b12aaa239e101aff4bcca79853760.jpg](https://pic.leetcode-cn.com/1650608674-vOmbUR-e4b12aaa239e101aff4bcca79853760.jpg)















# KMP

### 1.经典strStr

```
/*
    KMP算法
    找最长相等前后缀，回退
*/
void getnext(int *next,char *needle){
    int j=0;
    next[0]=0;
    for(int i=1;i<strlen(needle);++i){
        //不相等就回退
        while(j>0&&needle[i]!=needle[j]){
            j=next[j-1];
        }
        //相等就继续寻找
        if(needle[i]==needle[j])j++;
        //更新next数组
        next[i]=j;
    }
}
int strStr(char * haystack, char * needle){
    if(strlen(needle)==0)return 0;
    else if(strlen(haystack)==0)return -1;
    int next[strlen(needle)];
    getnext(next,needle); 
    for(int i=0,j=0;i<strlen(haystack);++i){
        //不匹配就回退
        while(j>0&&haystack[i]!=needle[j])j=next[j-1];
        //匹配
        if(haystack[i]==needle[j]){
            if(j==strlen(needle)-1)return i-j;
            j++;
        }
   }
   return -1;
}
```









# 位运算



```
# bit操作
& 符号，x & y ，会将两个十进制数在二进制下进行与运算
| 符号，x | y ，会将两个十进制数在二进制下进行或运算
^ 符号，x ^ y ，会将两个十进制数在二进制下进行异或运算
<< 符号，x << y 左移操作，最右边用 0 填充
>> 符号，x >> y 右移操作，最左边用 0 填充
~ 符号，~x ，按位取反操作，将 x 在二进制下的每一位取反

# 整数集合set位运算
# 整数集合做标志时，比如回溯时的visited标志数组
vstd 访问 i ：vstd | (1 << i)
vstd 离开 i ：vstd & ~(1 << i)
vstd 不包含 i : not vstd & (1 << i)

并集 ：A | B
交集 ：A & B
全集 ：(1 << n) - 1
补集 ：((1 << n) - 1) ^ A
子集 ：(A & B) == B
判断是否是 2 的幂 ：A & (A - 1) == 0
最低位的 1 变为 0 ：n &= (n - 1)
最低位的 1：A & (-A)，最低位的 1 一般记为 lowbit(A)
```

















### 1.位1的个数(simple)



 

```
int hammingWeight(uint32_t n) {
    int cnt=0;
    while(n){
        cnt+=(n&1);//每次判断最后一位是1还是0
        n>>=1;//右移一位
    }
    return cnt;
}
```

### 2.二进制表示中质数个计算置位



给你两个整数 left 和 right ，在闭区间 [left, right] 范围内，统计并返回 计算置位位数为质数 的整数个数。

计算置位位数 就是二进制表示中 1 的个数。

例如， 21 的二进制表示 10101 有 3 个计算置位。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



打表，int最多32个 1 



```
bool judge(int n){
    if(n==2||n==3||n==5||n==7||n==11||n==13||n==17||n==19)
    return true;
    else 
    return false;
}

int countPrimeSetBits(int left, int right){
    int ans=0;
    for(int i=left;i<=right;++i){
        int cnt=0;
        int j=i;
        while(j){
            if(j&1==1)cnt++;
            j>>=1;
        }
        if(judge(cnt))ans++;
    }
    return ans;
}
```



### 3.二进制间距



给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。

如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，"1001" 中的两个 1 的距离为 3 。

 

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-gap
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。





```
class Solution {
public:
    int binaryGap(int n) {
        int i=0,pre=0,falg=0;
        int count=0,maxcount=0;
        while(n){
            int a=n&1;
            //先找到第一个1的位置并记录
            if(a==1&&falg==0){
                pre=i;
                falg=1;
            }
            //i向后走遇见1就计算距离
            if(a==1&&falg==1){
                count=i-pre;
                pre=i;
            }
            i++;
            if(count>maxcount)maxcount=count;
            n=n>>1;
        }
        return maxcount;
    }
};
```





# 其他题目

### 1.寻找两个正序数组的中位数(困难)

算法的时间复杂度应该为 `O(log (m+n))` 。

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```



```c
/*
合并+排序
*/
int comp(void *a, void*b)
{
    return *(int*)a-*(int*)b;
}
double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){
    int a[nums1Size+nums2Size];//定义新数组

    for(int i=0;i<nums1Size;++i)a[i]=nums1[i];
    for(int i=nums1Size,j=0;i<nums1Size+nums2Size;++i)a[i]=nums2[j++];

    qsort(a,nums1Size+nums2Size,sizeof(int),comp);//合并数组并排序
    
    if((nums1Size+nums2Size)%2==0)return (float)(a[(nums1Size+nums2Size)/2]+a[(nums1Size+nums2Size)/2-1])/2;
    else return (float)a[(nums1Size+nums2Size)/2];
}
```



### 2.最长回文子串(中等)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```



解题思路
（中心扩散法）

​	1.定义left、right、index当作指针，left表示字符串开始下标，向左移；right表示字符串结束下标，向右移;index表示当前中心，向右移动。
​	2.如果字符串长度为0或1，直接返回s；
​	3.初始化max表示字符串长度 = 1，start = 0，index = 0；
​	4.定义*str用于表示返回串
​	5.index右移，当index < length - 1时循环：
​	6.初始化left = right = index,
​	7.当s[right + 1] == s[index++]时（有abbb情况）r++,中心指针index右移；right无法右移时退出本层循环；
​	8.left,right满足条件时（在串内），比较s[left - 1] 与 s[right + 1]，如果成立，分别往两边移动；
​	9.计算最大值及起始下标，开辟空间将字符串最后加‘0’结尾，返回str。

链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/leetcode5zui-chang-hui-wen-zi-chuan-by-y-box4/

```c
/*
用中心扩散法
    找到一个数，然后左右扩散，如果左边的数等于右边，就继续扩散
    每次记录最大值
*/
char * longestPalindrome(char * s){
    int len=strlen(s);
    if(len==0||len==1)return s;

    int max=1,start=0;
    int left=0,right=0,idex=0;
    char*str;
    while(idex<len-1){
        left=right=idex;

        while(s[idex++]==s[right+1]){ //如果连续相等就只移动右边
            if(++right==len-1)break;
        }

        while( (left>0)&& (right<len-1) && (s[left-1]==s[right+1]) ){//中心扩散
            left--;
            right++;
        }

        if(right-left+1>max){//每次记录最大值
            start=left;
            max=right-left+1;
        }
    }
    str=malloc(max+1);//留出一个'/0'
    strncpy(str,s+start,max);
    str[max]='\0';
    return str;
}
```



### 3.二分查照(简单)



给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-search



```c
int search(int* nums, int numsSize, int target){
    int left=0,right=numsSize-1;
    while(left<=right){//当left=right时，不能退出。别忘了！！
        int mid=(left+right)/2;
        if(nums[mid]==target)return mid;
        else if(nums[mid]>target)
                right=mid-1;
        else if(nums[mid]<target)
                left=mid+1;
    }
    return -1;
}
```

#### 搜索插入位置(简单)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。



```c
int searchInsert(int* nums, int numsSize, int target){
    int left=0,right=numsSize-1;
    while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]>target)
                right=mid-1;
        else if(nums[mid]<target)
                left=mid+1;
        else return mid;
    }
    return right+1;
}
```





### 4.采购方案





小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。

注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1

示例 1：

输入：nums = [2,5,3,5], target = 6

输出：1

解释：预算内仅能购买 nums[0] 与 nums[2]。

示例 2：

输入：nums = [2,2,1,9], target = 10

输出：4

解释：符合预算的采购方案如下：
nums[0] + nums[1] = 4
nums[0] + nums[2] = 3
nums[1] + nums[2] = 3
nums[2] + nums[3] = 10

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/4xy4Wx



```
/*
    排序加双指针
*/
int comp(const void*a,const void *b){
    return *(int*)a-*(int*)b;
}
int purchasePlans(int* nums, int numsSize, int target){
    qsort(nums,numsSize,sizeof(int),comp);
    int n=0;
    int left=0,right=numsSize-1;
    while(left<right){
        if(nums[left]+nums[right]>target)right--;
        else {
            n+=right-left;//灵魂---当nums[left]+nums[right]<=target时，找到多少个数和numss[left]相加小于target
            left++;
        }
        
        n=n%1000000007;
    }
    return n%1000000007;
}
```





### 5.(数学)嵌套数组

索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。

假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。

 

示例 1:

输入: A = [5,4,0,3,1,6,2]
输出: 4
解释: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/array-nesting
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



监狱100个盒子，每个盒子都有编号

```c++
class Solution {
public:
    int arrayNesting(vector<int>& nums) {
        int max=0;
        int len=nums.size();
        for(int i=0;i<len;++i)
        {
            if(nums[i]==-1)continue;
            if(max>len/2)return max;
            int cnt=1;
            int cur=nums[i];
            int pre=i;
            while(cur!=-1&&nums[i]!=nums[cur])
            {
                nums[pre]=-1;
                pre=cur;
                cur=nums[cur];
                cnt++;
            }
            max=max>cnt?max:cnt;
        }
        return max;
    }
};
```





# 知识点

### 1.malloc



#### 一维数组

reuslt=(int * )malloc(sizeof(int) * 2);

注：malloc 是 c 语言中的动态分配内存，result=(int * )malloc(sizeof(int) * 2； malloc 函数返回的是 void\* 型，所以要强制类型转换成 int，在前面加上 (int  * )，才能给整型赋值，后面 (sizeof(int)*2) 的意思是分配两个 int 大小的空间；

#### 二维数组

char **a=malloc(sizeof(char * ) * (列的数量));

对二维数组的列初始化，还要对行进行初始化

for(int i=0;i<col;++i){

​		a[0]=malloc(sizeof(char)*(每行的数量))；

}















### 2.qsort  

链接：https://leetcode-cn.com/circle/article/KBnaqU/

介绍一下qsort库函数
void qsort(void *arr, size_t n, size_t size, int (*cmp)(const void *, const void *))
arr表示要排序的序列，可以是数组名或指针
n表示arr中有多少待排序的元素
size表示arr中单个元素的大小（如果是动态分配内存的序列要注意）
cmp表示自定义的比较函数（核心！！！）



cmp框架

```
int cmp(const void *a, const void *b) {
    return;
}
```

这里要注意的是，cmp入参的a和b，是arr中的元素，即如果arr是数组，则a、b表示指向数组中某个元素的指针，如果arr是二维数组（数组的数组），则a、b表示指向arr中某个数组的指针

###### 一维数组/动态分配

```
int cmp(const void *a, const void *b) {
    return *(int*)a - *(int*)b;  /* a、b分别指向arr1/arr2中某个元素 */
}

int main()
{
    int arr1[] = { 5, 8, 6, 1, -3, 0, 1, 4 };
    qsort(arr1, sizeof(arr1) / sizeof(arr1[0]), sizeof(arr1[0]), cmp);

    int *arr2 = (int*)calloc(8, sizeof(int));
    arr2[0] = 5; arr2[1] = 8; arr2[2] = 6; arr2[3] = 1; arr2[4] = -3; arr2[5] = 0; arr2[6] = 1; arr2[7] = 4; 
    qsort(arr2, 8, sizeof(arr2[0]), cmp);  /* 如果将8改成sizeof(arr2) / sizeof(arr2[0])，排序会失败 */
}
```

### 3.关于链表的创建链接问题

```
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    struct ListNode *head=NULL,*tail=NULL;//初始化返回链表
    head=malloc(sizeof(struct ListNode));
    head->val=1;
    head->next=NULL;
    tail=head->next;//因为head->next是空，所以tail变为空，并不是head->next
    tail=malloc(sizeof(struct ListNode));
    tail->val=2;
    tail->next=NULL;
    //head->next=tail;
    return head;
}
```

输出[1]

问题：应该输出[1,2]

​			因为head->next是空，所以tail变为空，并不是head->next



### 4.strcpy和strncpy

头文件：#include <string.h>
strcpy() 函数用来复制字符串，其原型为：
char *strcpy(char *dest, const char *src);
【参数】dest 为目标字符串指针，src 为源字符串指针。
注意：src 和 dest 所指的内存区域不能重叠，且dest 必须有足够的空间放置 src 所包含的字符串（包含结束符NULL）。
【返回值】成功执行后返回目标数组指针 dest。
strcpy() 把src所指的由NULL结束的字符串复制到dest 所指的数组中，返回指向 dest 字符串的起始地址。
注意：如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。





strncpy()用来复制字符串的前n个字符，其原型为：
    char * strncpy(char *dest, const char *src, size_t n);
【参数说明】dest 为目标字符串指针，src 为源字符串指针。
strncpy()会将字符串src前n个字符拷贝到字符串dest。
不像strcpy()，strncpy()不会向dest追加结束标记'\0'，这就引发了很多不合常理的问题，将在下面的示例中说明。

如果src的前n个字节不含NULL字符，则结果不会以NULL字符结束。        
如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节。        
src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。    
注意：src 和 dest 所指的内存区域不能重叠，且dest 必须有足够的空间放置n个字符。
【返回值】返回指向dest的指针（该指向dest的最后一个元素） 

————————————————
原文链接：https://blog.csdn.net/qq_26093511/article/details/73338036



例子：其他题目->最长回文子串



### 5.srcmp



C 库函数 **int strcmp(const char \*str1, const char \*str2)** 把 **str1** 所指向的字符串和 **str2** 所指向的字符串进行比较。



- 如果返回值小于 0，则表示 str1 小于 str2。
- 如果返回值大于 0，则表示 str1 大于 str2。
- 如果返回值等于 0，则表示 str1 等于 str2。



### 6.字符串

字符串的字串



**对于一个字符串变量，例如"adereegfbw",它的子串就是像"ader"这样可以从中找到的连续的字符串。字符串"adereegfbw"本身也属于它本身最长的子串。**

#### c语言 atoi函数

#### (将字符串转换为整数)

函数说明 atoi()会扫描参数nptr字符串，跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时('\0')才结束转换，并将结果返回。
返回值 返回转换后的整型数。

```
 int atoi(const char *nptr);
```

```
/*
* name:xif
* coder:xifan@2010@yahoo.cn
* time:08.20.2012
* file_name:my_atoi.c
* function:int my_atoi(char* pstr)
*/
 
int my_atoi(char* pstr)
{
	int Ret_Integer = 0;
	int Integer_sign = 1;
	
	/*
	* 判断指针是否为空
	*/
	if(pstr == NULL)
	{
		printf("Pointer is NULL\n");
		return 0;
	}
	
	/*
	* 跳过前面的空格字符
	*/
	while(isspace(*pstr) == 0)
	{
		pstr++;
	}
	
	/*
	* 判断正负号
	* 如果是正号，指针指向下一个字符
	* 如果是符号，把符号标记为Integer_sign置-1，然后再把指针指向下一个字符
	*/
	if(*pstr == '-')
	{
		Integer_sign = -1;
	}
	if(*pstr == '-' || *pstr == '+')
	{
		pstr++;
	}
	
	/*
	* 把数字字符串逐个转换成整数，并把最后转换好的整数赋给Ret_Integer
	*/
	while(*pstr >= '0' && *pstr <= '9')
	{
		Ret_Integer = Ret_Integer * 10 + *pstr - '0';
		pstr++;
	}
	Ret_Integer = Integer_sign * Ret_Integer;
	
	return Ret_Integer;
}
```





### 7.位运算



| &    | 与   | 两个位都为1时，结果才为1                                     |
| ---- | ---- | ------------------------------------------------------------ |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |



### sprintf函数

sprintf()函数用于将格式化的数据写入字符串，其原型为：

# 问题

### 1.注意细节

判断字符串是否唯一



实现一个算法，确定一个字符串 `s` 的所有字符是否全都不同。

输入：leetcode

输出：false



输入：abc

输出：true



**如果我是面试官，我会希望看到什么？**

**可能有点偏题，毕竟这里主要就是做题的地方。。**

**如果我是面试官，会考虑主要考察什么，就我的工作经验看，大多数主要是招聘工程师的，面试者如果什么问题都没有，直接写个二重循环搞定，会首先给个50分，如果能写点判断字符串是否为null的，60分。**

**直接上手什么bitset，什么位运算的，我会先问他，题目中有没有交代字符串的字符一定是26个英文字母？如果是unicode环境，你是不是要准备2^16/8个字节的空间？在实际项目中，风险可控，结果可期更重要，绝大多数时候不在乎那点时间和资源。**

**所以我期望面试者不要急于解答，我希望他先问我问题：**

1. **字符串的字符范围，如果我告诉他，26个小写英文字母，那可能一开头直接判断如果字符长度>26, 直接返回False，做到这一点的，80分**
2. **如果我告诉他ascii字符集，然后他的代码里有边界检查，并且针对不同的范围有不同的侧重点，比如说ascii字符集，那也就是128个可能性，16个字节的位运算比较好**
3. **如果我告诉他是unicode，没有字符范围，老老实实排序再判断是比较符合我对工程师的要求的，因为算法性能稳定，没有额外资源要求，一眼看出没什么不可预见的风险，100分。**

**就是说，有些东西，没想到或者一时没想到根本不是问题，日常工作中稍微提示一下即可，但是缜密的思维对于程序员来说更重要。**
